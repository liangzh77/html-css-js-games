<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ–‡æ˜ä¹‹å…‰</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  color: #e0e0e0;
  font-family: "Microsoft YaHei", "SimHei", sans-serif;
  overflow: hidden;
  height: 100vh;
  user-select: none;
}
#game-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}
#top-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: linear-gradient(180deg, #16213e, #0f3460);
  padding: 6px 16px;
  border-bottom: 2px solid #e94560;
  min-height: 44px;
  z-index: 10;
}
#top-bar .title {
  font-size: 20px;
  font-weight: bold;
  color: #e94560;
  letter-spacing: 2px;
  text-shadow: 0 0 10px rgba(233,69,96,0.5);
}
#resources {
  display: flex;
  gap: 20px;
  font-size: 14px;
}
.res-item {
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(255,255,255,0.08);
  padding: 3px 10px;
  border-radius: 4px;
}
.res-icon { font-size: 16px; }
#turn-info {
  display: flex;
  align-items: center;
  gap: 12px;
}
#turn-num {
  font-size: 14px;
  color: #aaa;
}
#btn-end-turn {
  background: linear-gradient(135deg, #e94560, #c0392b);
  color: #fff;
  border: none;
  padding: 6px 18px;
  border-radius: 4px;
  font-size: 14px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s;
}
#btn-end-turn:hover {
  background: linear-gradient(135deg, #ff6b81, #e94560);
  transform: scale(1.05);
}
#main-area {
  display: flex;
  flex: 1;
  overflow: hidden;
}
#canvas-wrapper {
  flex: 1;
  position: relative;
  overflow: hidden;
}
#gameCanvas {
  position: absolute;
  top: 0;
  left: 0;
  cursor: grab;
}
#gameCanvas:active { cursor: grabbing; }
#right-panel {
  width: 260px;
  background: #16213e;
  border-left: 2px solid #0f3460;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
}
#minimap-container {
  padding: 8px;
  border-bottom: 1px solid #0f3460;
}
#minimap-container h3 {
  font-size: 13px;
  color: #aaa;
  margin-bottom: 4px;
}
#minimapCanvas {
  width: 100%;
  border: 1px solid #0f3460;
  cursor: pointer;
  display: block;
}
#info-panel {
  padding: 10px;
  flex: 1;
  overflow-y: auto;
}
#info-panel h3 {
  font-size: 14px;
  color: #e94560;
  margin-bottom: 8px;
  border-bottom: 1px solid #333;
  padding-bottom: 4px;
}
.info-section {
  margin-bottom: 12px;
}
.info-row {
  display: flex;
  justify-content: space-between;
  font-size: 13px;
  padding: 2px 0;
  color: #ccc;
}
.info-row .label { color: #888; }
.action-buttons {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 6px;
}
.action-btn {
  background: #0f3460;
  color: #e0e0e0;
  border: 1px solid #1a5276;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
  font-family: inherit;
  text-align: left;
  transition: all 0.15s;
}
.action-btn:hover {
  background: #1a5276;
  border-color: #e94560;
}
.action-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.action-btn .cost {
  color: #888;
  font-size: 11px;
}
#notifications {
  position: absolute;
  top: 50px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 4px;
  pointer-events: none;
}
.notification {
  background: rgba(15, 52, 96, 0.95);
  color: #e0e0e0;
  padding: 8px 20px;
  border-radius: 4px;
  border-left: 3px solid #e94560;
  font-size: 13px;
  animation: notifIn 0.3s ease, notifOut 0.5s ease 2.5s forwards;
  white-space: nowrap;
}
@keyframes notifIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes notifOut {
  to { opacity: 0; transform: translateY(-10px); }
}
#game-over-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  z-index: 200;
  justify-content: center;
  align-items: center;
}
#game-over-overlay.show {
  display: flex;
}
#game-over-box {
  background: #16213e;
  border: 2px solid #e94560;
  border-radius: 12px;
  padding: 40px 60px;
  text-align: center;
}
#game-over-box h1 {
  font-size: 36px;
  margin-bottom: 16px;
}
#game-over-box p {
  font-size: 18px;
  color: #aaa;
  margin-bottom: 24px;
}
#game-over-box button {
  background: linear-gradient(135deg, #e94560, #c0392b);
  color: #fff;
  border: none;
  padding: 10px 30px;
  border-radius: 6px;
  font-size: 16px;
  font-family: inherit;
  cursor: pointer;
}
#game-over-box button:hover {
  background: linear-gradient(135deg, #ff6b81, #e94560);
}
#bottom-bar {
  background: #16213e;
  border-top: 1px solid #0f3460;
  padding: 4px 16px;
  font-size: 12px;
  color: #666;
  display: flex;
  justify-content: space-between;
}
.unit-moves-bar {
  height: 3px;
  background: #333;
  border-radius: 2px;
  margin-top: 2px;
  overflow: hidden;
}
.unit-moves-fill {
  height: 100%;
  background: #2ecc71;
  border-radius: 2px;
  transition: width 0.2s;
}
.health-bar {
  height: 3px;
  background: #333;
  border-radius: 2px;
  margin-top: 1px;
  overflow: hidden;
}
.health-fill {
  height: 100%;
  background: #e74c3c;
  border-radius: 2px;
  transition: width 0.2s;
}
.city-build-progress {
  height: 4px;
  background: #333;
  border-radius: 2px;
  margin-top: 3px;
  overflow: hidden;
}
.city-build-fill {
  height: 100%;
  background: #3498db;
  border-radius: 2px;
}
</style>
</head>
<body>
<div id="game-container">
  <div id="top-bar">
    <div class="title">æ–‡æ˜ä¹‹å…‰</div>
    <div id="resources">
      <div class="res-item"><span class="res-icon">ğŸª™</span><span>é‡‘å¸: <span id="res-gold">0</span> (<span id="res-gold-rate">+0</span>/å›åˆ)</span></div>
      <div class="res-item"><span class="res-icon">ğŸ”¬</span><span>ç§‘æŠ€: <span id="res-science">0</span></span></div>
      <div class="res-item"><span class="res-icon">ğŸ‘¥</span><span>æ€»äººå£: <span id="res-pop">0</span></span></div>
    </div>
    <div id="turn-info">
      <span id="turn-num">å›åˆ: 1</span>
      <button id="btn-end-turn">ç»“æŸå›åˆ</button>
    </div>
  </div>
  <div id="main-area">
    <div id="canvas-wrapper">
      <canvas id="gameCanvas"></canvas>
      <div id="notifications"></div>
    </div>
    <div id="right-panel">
      <div id="minimap-container">
        <h3>å°åœ°å›¾</h3>
        <canvas id="minimapCanvas" width="240" height="240"></canvas>
      </div>
      <div id="info-panel">
        <h3>ä¿¡æ¯é¢æ¿</h3>
        <div id="info-content">
          <p style="color:#888;font-size:13px;">ç‚¹å‡»åœ°å›¾ä¸Šçš„å•ä½æˆ–åŸå¸‚æŸ¥çœ‹è¯¦æƒ…</p>
        </div>
      </div>
    </div>
  </div>
  <div id="bottom-bar">
    <span id="coord-display">åæ ‡: -</span>
    <span id="terrain-display">åœ°å½¢: -</span>
    <span>æ–‡æ˜ä¹‹å…‰ v1.0 | é¼ æ ‡æ‹–æ‹½ç§»åŠ¨åœ°å›¾</span>
  </div>
</div>
<div id="game-over-overlay">
  <div id="game-over-box">
    <h1 id="game-over-title"></h1>
    <p id="game-over-msg"></p>
    <button onclick="location.reload()">é‡æ–°å¼€å§‹</button>
  </div>
</div>

<script>
// ============================================================
// æ–‡æ˜ä¹‹å…‰ - Simplified Civilization / Freeciv-inspired Strategy Game
// ============================================================

const TILE = 40;
const MAP_W = 30;
const MAP_H = 30;
const CANVAS_PX_W = MAP_W * TILE;
const CANVAS_PX_H = MAP_H * TILE;

// Terrain enum
const T = { WATER: 0, PLAINS: 1, FOREST: 2, MOUNTAIN: 3, DESERT: 4 };
const TERRAIN_NAMES = ['æµ·æ´‹', 'å¹³åŸ', 'æ£®æ—', 'å±±åœ°', 'æ²™æ¼ '];
const TERRAIN_COLORS = {
  [T.WATER]:    '#3b82c4',
  [T.PLAINS]:   '#8aba5c',
  [T.FOREST]:   '#3d7a3d',
  [T.MOUNTAIN]: '#8b8682',
  [T.DESERT]:   '#d4b96a',
};
const TERRAIN_COLORS_DARK = {
  [T.WATER]:    '#2a5f8f',
  [T.PLAINS]:   '#6d9446',
  [T.FOREST]:   '#2d5c2d',
  [T.MOUNTAIN]: '#6b6662',
  [T.DESERT]:   '#b49a52',
};

// Terrain yields: [food, production, gold]
const TERRAIN_YIELD = {
  [T.WATER]:    [1, 0, 1],
  [T.PLAINS]:   [2, 1, 1],
  [T.FOREST]:   [1, 2, 0],
  [T.MOUNTAIN]: [0, 2, 1],
  [T.DESERT]:   [0, 1, 1],
};

// Unit types
const UNIT_TYPES = {
  warrior: { name: 'æˆ˜å£«', symbol: 'âš”', hp: 100, attack: 30, defense: 20, moves: 2, cost: 20 },
  settler: { name: 'å¼€æ‹“è€…', symbol: 'ğŸ•', hp: 50, attack: 0, defense: 5, moves: 2, cost: 40 },
  worker:  { name: 'å·¥äºº', symbol: 'â›', hp: 30, attack: 0, defense: 5, moves: 2, cost: 25 },
};

// City improvements
const IMPROVEMENTS = {
  granary:   { name: 'ç²®ä»“', cost: 30, food: 2, production: 0, gold: 0, desc: '+2 é£Ÿç‰©' },
  workshop:  { name: 'å·¥åŠ', cost: 35, food: 0, production: 2, gold: 0, desc: '+2 äº§èƒ½' },
  market:    { name: 'å¸‚åœº', cost: 30, food: 0, production: 0, gold: 3, desc: '+3 é‡‘å¸' },
  barracks:  { name: 'å…µè¥', cost: 25, food: 0, production: 1, gold: 0, desc: '+1 äº§èƒ½, åŠ é€Ÿè®­ç»ƒ' },
  walls:     { name: 'åŸå¢™', cost: 40, food: 0, production: 0, gold: 0, desc: 'åŸå¸‚é˜²å¾¡ +50%' },
  library:   { name: 'å›¾ä¹¦é¦†', cost: 35, food: 0, production: 0, gold: 1, desc: '+1 é‡‘å¸, +ç§‘æŠ€' },
};

const PLAYER_COLORS = ['#3498db', '#e74c3c'];
const PLAYER_NAMES = ['ç©å®¶', 'AIå¸å›½'];

// ============================================================
// Game State
// ============================================================
let map = [];
let explored = [];  // [playerId][y][x]
let units = [];
let cities = [];
let turn = 1;
let currentPlayer = 0;
let selectedUnit = null;
let selectedCity = null;
let gold = [50, 50];
let science = [0, 0];
let gameOver = false;

// Camera
let camX = 0, camY = 0;
let isDragging = false;
let dragStartX, dragStartY, dragCamStartX, dragCamStartY;

// Canvas
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimapCanvas');
const mctx = minimapCanvas.getContext('2d');
const wrapper = document.getElementById('canvas-wrapper');

// ============================================================
// Map Generation
// ============================================================
function generateMap() {
  // Simple Perlin-like noise using multiple octaves of random
  const noise = [];
  for (let y = 0; y < MAP_H; y++) {
    noise[y] = [];
    for (let x = 0; x < MAP_W; x++) {
      noise[y][x] = Math.random();
    }
  }
  // Smooth
  function smooth(arr, passes) {
    for (let p = 0; p < passes; p++) {
      const n2 = [];
      for (let y = 0; y < MAP_H; y++) {
        n2[y] = [];
        for (let x = 0; x < MAP_W; x++) {
          let sum = 0, c = 0;
          for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
              const ny = y+dy, nx = x+dx;
              if (ny >= 0 && ny < MAP_H && nx >= 0 && nx < MAP_W) {
                sum += arr[ny][nx];
                c++;
              }
            }
          }
          n2[y][x] = sum / c;
        }
      }
      for (let y = 0; y < MAP_H; y++)
        for (let x = 0; x < MAP_W; x++)
          arr[y][x] = n2[y][x];
    }
  }
  smooth(noise, 4);

  // Secondary noise for variety
  const noise2 = [];
  for (let y = 0; y < MAP_H; y++) {
    noise2[y] = [];
    for (let x = 0; x < MAP_W; x++) noise2[y][x] = Math.random();
  }
  smooth(noise2, 3);

  map = [];
  for (let y = 0; y < MAP_H; y++) {
    map[y] = [];
    for (let x = 0; x < MAP_W; x++) {
      const v = noise[y][x];
      const v2 = noise2[y][x];
      // Edge water
      const edgeDist = Math.min(x, y, MAP_W-1-x, MAP_H-1-y);
      const edgeFactor = Math.min(edgeDist / 4, 1);
      const adjusted = v * edgeFactor;

      if (adjusted < 0.32) map[y][x] = T.WATER;
      else if (adjusted < 0.42) map[y][x] = v2 > 0.5 ? T.DESERT : T.PLAINS;
      else if (adjusted < 0.58) map[y][x] = T.PLAINS;
      else if (adjusted < 0.72) map[y][x] = v2 > 0.55 ? T.FOREST : T.PLAINS;
      else if (adjusted < 0.82) map[y][x] = T.FOREST;
      else map[y][x] = T.MOUNTAIN;
    }
  }

  // Ensure explored arrays
  explored = [];
  for (let p = 0; p < 2; p++) {
    explored[p] = [];
    for (let y = 0; y < MAP_H; y++) {
      explored[p][y] = [];
      for (let x = 0; x < MAP_W; x++) explored[p][y][x] = false;
    }
  }
}

function isLand(x, y) {
  return x >= 0 && x < MAP_W && y >= 0 && y < MAP_H && map[y][x] !== T.WATER;
}

function findStartPos(avoidX) {
  let attempts = 0;
  while (attempts < 1000) {
    const x = 3 + Math.floor(Math.random() * (MAP_W - 6));
    const y = 3 + Math.floor(Math.random() * (MAP_H - 6));
    if (isLand(x, y) && map[y][x] === T.PLAINS) {
      if (avoidX === undefined || Math.abs(x - avoidX) > 8) {
        // Check surroundings have some land
        let landCount = 0;
        for (let dy = -2; dy <= 2; dy++)
          for (let dx = -2; dx <= 2; dx++)
            if (isLand(x+dx, y+dy)) landCount++;
        if (landCount >= 15) return {x, y};
      }
    }
    attempts++;
  }
  // Fallback
  for (let y = 5; y < MAP_H-5; y++)
    for (let x = 5; x < MAP_W-5; x++)
      if (isLand(x, y) && map[y][x] === T.PLAINS)
        if (avoidX === undefined || Math.abs(x - avoidX) > 6)
          return {x, y};
  return {x: Math.floor(MAP_W/2), y: Math.floor(MAP_H/2)};
}

// ============================================================
// Visibility / Fog of War
// ============================================================
function revealAround(playerId, cx, cy, radius) {
  for (let dy = -radius; dy <= radius; dy++) {
    for (let dx = -radius; dx <= radius; dx++) {
      const nx = cx + dx, ny = cy + dy;
      if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H) {
        if (dx*dx + dy*dy <= radius*radius + 1) {
          explored[playerId][ny][nx] = true;
        }
      }
    }
  }
}

function isVisible(playerId, x, y) {
  // Visible if any unit or city of player is within range
  for (const u of units) {
    if (u.owner === playerId) {
      const d = Math.abs(u.x - x) + Math.abs(u.y - y);
      if (d <= 3) return true;
    }
  }
  for (const c of cities) {
    if (c.owner === playerId) {
      const d = Math.abs(c.x - x) + Math.abs(c.y - y);
      if (d <= 3) return true;
    }
  }
  return false;
}

// ============================================================
// Entity Creation
// ============================================================
let nextUnitId = 1;
let nextCityId = 1;

function createUnit(owner, type, x, y) {
  const t = UNIT_TYPES[type];
  const u = {
    id: nextUnitId++,
    owner, type, x, y,
    hp: t.hp,
    maxHp: t.hp,
    movesLeft: t.moves,
    maxMoves: t.moves,
    fortified: false,
  };
  units.push(u);
  revealAround(owner, x, y, 3);
  return u;
}

function createCity(owner, x, y, name) {
  const c = {
    id: nextCityId++,
    owner, x, y, name,
    population: 1,
    food: 0,
    foodNeeded: 20,
    production: 0,
    buildQueue: null,    // { type: 'unit'|'improvement', key: string }
    buildProgress: 0,
    improvements: [],
    hp: 200,
    maxHp: 200,
  };
  cities.push(c);
  // Remove forest/mountain under city
  if (map[y][x] !== T.PLAINS && map[y][x] !== T.DESERT) map[y][x] = T.PLAINS;
  revealAround(owner, x, y, 3);
  return c;
}

// ============================================================
// City Mechanics
// ============================================================
function getCityYields(city) {
  let food = 2, prod = 1, goldY = 1;
  // From surrounding tiles
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = city.x + dx, ny = city.y + dy;
      if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H) {
        const ty = TERRAIN_YIELD[map[ny][nx]];
        food += ty[0];
        prod += ty[1];
        goldY += ty[2];
      }
    }
  }
  // Population bonus
  food += Math.floor(city.population * 0.5);
  prod += Math.floor(city.population * 0.3);
  goldY += Math.floor(city.population * 0.2);
  // Improvements
  for (const imp of city.improvements) {
    const info = IMPROVEMENTS[imp];
    food += info.food;
    prod += info.production;
    goldY += info.gold;
  }
  return { food, prod, gold: goldY };
}

function getBuildCost(buildItem) {
  if (!buildItem) return 999;
  if (buildItem.type === 'unit') return UNIT_TYPES[buildItem.key].cost;
  if (buildItem.type === 'improvement') return IMPROVEMENTS[buildItem.key].cost;
  return 999;
}

function processCity(city) {
  const yields = getCityYields(city);
  // Food & growth
  const foodConsumption = city.population * 2;
  city.food += yields.food - foodConsumption;
  if (city.food >= city.foodNeeded) {
    city.population++;
    city.food = 0;
    city.foodNeeded = Math.floor(20 * Math.pow(1.3, city.population - 1));
    if (city.owner === 0) notify(`${city.name} äººå£å¢é•¿è‡³ ${city.population}!`);
  }
  if (city.food < 0) {
    city.food = 0;
    if (city.population > 1) {
      city.population--;
      if (city.owner === 0) notify(`${city.name} é¥¥è’! äººå£å‡å°‘è‡³ ${city.population}`);
    }
  }
  // Production
  if (city.buildQueue) {
    const hasBrk = city.improvements.includes('barracks');
    let prodBonus = yields.prod;
    if (hasBrk && city.buildQueue.type === 'unit') prodBonus = Math.floor(prodBonus * 1.3);
    city.buildProgress += prodBonus;
    const cost = getBuildCost(city.buildQueue);
    if (city.buildProgress >= cost) {
      city.buildProgress = 0;
      if (city.buildQueue.type === 'unit') {
        // Find adjacent empty land tile
        let placed = false;
        const dirs = [[0,0],[0,-1],[1,0],[0,1],[-1,0],[1,-1],[1,1],[-1,1],[-1,-1]];
        for (const [dx, dy] of dirs) {
          const nx = city.x+dx, ny = city.y+dy;
          if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H && map[ny][nx] !== T.WATER) {
            if (!units.find(u => u.x === nx && u.y === ny && u.owner === city.owner)) {
              createUnit(city.owner, city.buildQueue.key, nx, ny);
              placed = true;
              break;
            }
          }
        }
        if (!placed) createUnit(city.owner, city.buildQueue.key, city.x, city.y);
        if (city.owner === 0) notify(`${city.name} å®Œæˆè®­ç»ƒ: ${UNIT_TYPES[city.buildQueue.key].name}`);
      } else if (city.buildQueue.type === 'improvement') {
        city.improvements.push(city.buildQueue.key);
        if (city.owner === 0) notify(`${city.name} å»ºé€ å®Œæˆ: ${IMPROVEMENTS[city.buildQueue.key].name}`);
      }
      city.buildQueue = null;
    }
  }
  // Gold
  gold[city.owner] += yields.gold;
  // Science
  const sciBonus = city.improvements.includes('library') ? 2 : 1;
  science[city.owner] += city.population * sciBonus;
  // City heal
  if (city.hp < city.maxHp) city.hp = Math.min(city.maxHp, city.hp + 10);
}

// ============================================================
// Unit Movement & Combat
// ============================================================
function getMoveCost(x, y) {
  if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return Infinity;
  const t = map[y][x];
  if (t === T.WATER) return Infinity;
  if (t === T.MOUNTAIN) return 2;
  if (t === T.FOREST) return 1.5;
  return 1;
}

function moveUnit(unit, tx, ty) {
  if (gameOver) return false;
  const cost = getMoveCost(tx, ty);
  if (cost === Infinity) return false;
  if (unit.movesLeft < 1) return false;

  // Check distance (only adjacent moves)
  const dx = Math.abs(unit.x - tx);
  const dy = Math.abs(unit.y - ty);
  if (dx > 1 || dy > 1 || (dx === 0 && dy === 0)) return false;

  // Check for enemy unit
  const enemyUnit = units.find(u => u.x === tx && u.y === ty && u.owner !== unit.owner);
  if (enemyUnit) {
    if (UNIT_TYPES[unit.type].attack <= 0) {
      if (unit.owner === 0) notify('è¯¥å•ä½æ— æ³•æ”»å‡»!');
      return false;
    }
    combat(unit, enemyUnit);
    unit.movesLeft = 0;
    return true;
  }

  // Check for enemy city
  const enemyCity = cities.find(c => c.x === tx && c.y === ty && c.owner !== unit.owner);
  if (enemyCity && UNIT_TYPES[unit.type].attack > 0) {
    attackCity(unit, enemyCity);
    unit.movesLeft = 0;
    return true;
  }

  // Check for friendly unit blocking
  const friendlyUnit = units.find(u => u.x === tx && u.y === ty && u.owner === unit.owner);
  if (friendlyUnit) return false;

  unit.x = tx;
  unit.y = ty;
  unit.movesLeft = Math.max(0, unit.movesLeft - cost);
  unit.fortified = false;
  revealAround(unit.owner, tx, ty, 3);
  return true;
}

function combat(attacker, defender) {
  const aType = UNIT_TYPES[attacker.type];
  const dType = UNIT_TYPES[defender.type];
  let atkPow = aType.attack * (0.8 + Math.random() * 0.4);
  let defPow = dType.defense * (0.8 + Math.random() * 0.4);

  if (defender.fortified) defPow *= 1.3;
  if (map[defender.y][defender.x] === T.FOREST) defPow *= 1.2;
  if (map[defender.y][defender.x] === T.MOUNTAIN) defPow *= 1.5;

  // In city bonus
  const inCity = cities.find(c => c.x === defender.x && c.y === defender.y && c.owner === defender.owner);
  if (inCity) {
    defPow *= 1.3;
    if (inCity.improvements.includes('walls')) defPow *= 1.5;
  }

  defender.hp -= Math.max(5, Math.round(atkPow));
  attacker.hp -= Math.max(3, Math.round(defPow * 0.5));

  if (attacker.owner === 0 || defender.owner === 0) {
    notify(`æˆ˜æ–—! ${PLAYER_NAMES[attacker.owner]}çš„${aType.name} vs ${PLAYER_NAMES[defender.owner]}çš„${dType.name}`);
  }

  if (defender.hp <= 0) {
    units = units.filter(u => u !== defender);
    if (attacker.owner === 0) notify(`æ•Œæ–¹${dType.name}è¢«æ¶ˆç­!`);
    else if (defender.owner === 0) notify(`æˆ‘æ–¹${dType.name}è¢«æ¶ˆç­!`);
    // Move attacker to defender position if alive
    if (attacker.hp > 0) {
      attacker.x = defender.x;
      attacker.y = defender.y;
    }
  }
  if (attacker.hp <= 0) {
    units = units.filter(u => u !== attacker);
    if (attacker.owner === 0) notify(`æˆ‘æ–¹${aType.name}è¢«æ¶ˆç­!`);
    else if (defender.owner === 0) notify(`æ•Œæ–¹${aType.name}è¢«æ¶ˆç­!`);
  }
}

function attackCity(unit, city) {
  const aType = UNIT_TYPES[unit.type];
  let atkPow = aType.attack * (0.8 + Math.random() * 0.4);
  let defPow = 15 * (0.8 + Math.random() * 0.4);
  if (city.improvements.includes('walls')) defPow *= 2;

  city.hp -= Math.max(5, Math.round(atkPow));
  unit.hp -= Math.max(3, Math.round(defPow * 0.5));

  if (unit.owner === 0) notify(`æ”»å‡»åŸå¸‚ ${city.name}! (åŸå¸‚HP: ${Math.max(0,city.hp)}/${city.maxHp})`);

  if (city.hp <= 0) {
    // Conquer city
    const oldOwner = city.owner;
    city.owner = unit.owner;
    city.hp = Math.floor(city.maxHp * 0.3);
    city.population = Math.max(1, city.population - 1);
    city.buildQueue = null;
    city.buildProgress = 0;
    if (unit.hp > 0) {
      unit.x = city.x;
      unit.y = city.y;
    }
    if (unit.owner === 0) notify(`å¾æœäº†åŸå¸‚ ${city.name}!`);
    else notify(`${city.name} è¢«æ•Œæ–¹å¾æœ!`);
    checkWinCondition();
  }
  if (unit.hp <= 0) {
    units = units.filter(u => u !== unit);
    if (unit.owner === 0) notify(`æˆ‘æ–¹${aType.name}åœ¨æ”»åŸæ—¶è¢«æ¶ˆç­!`);
  }
}

function foundCity(settler) {
  if (map[settler.y][settler.x] === T.WATER) {
    notify('æ— æ³•åœ¨æ°´ä¸Šå»ºåŸ!');
    return;
  }
  // Check proximity to other cities
  for (const c of cities) {
    if (Math.abs(c.x - settler.x) <= 2 && Math.abs(c.y - settler.y) <= 2) {
      notify('è·ç¦»å…¶ä»–åŸå¸‚å¤ªè¿‘!');
      return;
    }
  }
  const cityNames0 = ['é•¿å®‰', 'æ´›é˜³', 'é‡‘é™µ', 'ä¸´å®‰', 'å¼€å°', 'æˆéƒ½', 'å¹¿å·', 'æ­¦æ±‰'];
  const cityNames1 = ['ç½—é©¬', 'é›…å…¸', 'å·´æ¯”ä¼¦', 'å­Ÿè²æ–¯', 'è¿¦å¤ªåŸº', 'æ³¢æ–¯æ³¢åˆ©æ–¯'];
  const owned = cities.filter(c => c.owner === settler.owner);
  const names = settler.owner === 0 ? cityNames0 : cityNames1;
  const name = names[owned.length % names.length];
  createCity(settler.owner, settler.x, settler.y, name);
  units = units.filter(u => u !== settler);
  selectedUnit = null;
  notify(`å»ºç«‹äº†æ–°åŸå¸‚: ${name}!`);
  revealAround(settler.owner, settler.x, settler.y, 3);
}

// ============================================================
// AI
// ============================================================
function aiTurn() {
  const aiUnits = units.filter(u => u.owner === 1);
  const aiCities = cities.filter(c => c.owner === 1);
  const playerCities = cities.filter(c => c.owner === 0);

  // City production
  for (const city of aiCities) {
    if (!city.buildQueue) {
      const myUnits = units.filter(u => u.owner === 1);
      const warriors = myUnits.filter(u => u.type === 'warrior');
      if (warriors.length < aiCities.length * 2 + 1) {
        city.buildQueue = { type: 'unit', key: 'warrior' };
      } else if (myUnits.filter(u => u.type === 'settler').length === 0 && aiCities.length < 3 && gold[1] > 30) {
        city.buildQueue = { type: 'unit', key: 'settler' };
      } else if (!city.improvements.includes('barracks')) {
        city.buildQueue = { type: 'improvement', key: 'barracks' };
      } else if (!city.improvements.includes('granary')) {
        city.buildQueue = { type: 'improvement', key: 'granary' };
      } else if (!city.improvements.includes('walls')) {
        city.buildQueue = { type: 'improvement', key: 'walls' };
      } else {
        city.buildQueue = { type: 'unit', key: 'warrior' };
      }
    }
  }

  // Unit AI
  for (const unit of aiUnits) {
    if (unit.movesLeft <= 0) continue;

    if (unit.type === 'settler') {
      // Move away from cities and try to found
      const nearCity = cities.find(c => Math.abs(c.x - unit.x) <= 2 && Math.abs(c.y - unit.y) <= 2);
      if (!nearCity && isLand(unit.x, unit.y)) {
        foundCity(unit);
        continue;
      }
      // Move randomly on land away from cities
      aiMoveRandom(unit);
      continue;
    }

    if (unit.type === 'warrior') {
      // Find nearest enemy
      let nearestEnemy = null;
      let nearestDist = Infinity;
      for (const eu of units) {
        if (eu.owner === 1) continue;
        const d = Math.abs(eu.x - unit.x) + Math.abs(eu.y - unit.y);
        if (d < nearestDist) { nearestDist = d; nearestEnemy = eu; }
      }
      // Also consider enemy cities
      for (const ec of playerCities) {
        const d = Math.abs(ec.x - unit.x) + Math.abs(ec.y - unit.y);
        if (d < nearestDist) { nearestDist = d; nearestEnemy = ec; }
      }

      if (nearestEnemy && nearestDist <= 10) {
        // Move toward enemy
        aiMoveToward(unit, nearestEnemy.x, nearestEnemy.y);
      } else {
        // Patrol near own cities or move randomly
        if (aiCities.length > 0) {
          const homeCity = aiCities[Math.floor(Math.random() * aiCities.length)];
          const distHome = Math.abs(unit.x - homeCity.x) + Math.abs(unit.y - homeCity.y);
          if (distHome > 5) {
            aiMoveToward(unit, homeCity.x, homeCity.y);
          } else {
            aiMoveRandom(unit);
          }
        } else {
          aiMoveRandom(unit);
        }
      }
    }
  }
}

function aiMoveToward(unit, tx, ty) {
  let bestDx = 0, bestDy = 0, bestDist = Infinity;
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (dx === 0 && dy === 0) continue;
      const nx = unit.x + dx, ny = unit.y + dy;
      if (getMoveCost(nx, ny) === Infinity) continue;
      const d = Math.abs(nx - tx) + Math.abs(ny - ty);
      if (d < bestDist) {
        // Don't walk into friendly units
        const friendly = units.find(u => u.x === nx && u.y === ny && u.owner === unit.owner);
        if (!friendly) {
          bestDist = d;
          bestDx = dx;
          bestDy = dy;
        }
      }
    }
  }
  if (bestDx !== 0 || bestDy !== 0) {
    moveUnit(unit, unit.x + bestDx, unit.y + bestDy);
    // Try second move
    if (unit.movesLeft > 0 && units.includes(unit)) {
      aiMoveToward(unit, tx, ty);
    }
  }
}

function aiMoveRandom(unit) {
  const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]];
  const shuffled = dirs.sort(() => Math.random() - 0.5);
  for (const [dx, dy] of shuffled) {
    const nx = unit.x + dx, ny = unit.y + dy;
    if (getMoveCost(nx, ny) < Infinity) {
      const occupied = units.find(u => u.x === nx && u.y === ny);
      if (!occupied) {
        moveUnit(unit, nx, ny);
        return;
      }
    }
  }
}

// ============================================================
// Turn Processing
// ============================================================
function endTurn() {
  if (gameOver) return;

  // Process player cities
  for (const city of cities) {
    if (city.owner === 0) processCity(city);
  }

  // Heal player units
  for (const u of units) {
    if (u.owner === 0 && u.hp < u.maxHp) {
      const inCity = cities.find(c => c.x === u.x && c.y === u.y && c.owner === u.owner);
      u.hp = Math.min(u.maxHp, u.hp + (inCity ? 15 : 5));
    }
  }

  // AI Turn
  aiTurn();

  // Process AI cities
  for (const city of cities) {
    if (city.owner === 1) processCity(city);
  }

  // Heal AI units
  for (const u of units) {
    if (u.owner === 1 && u.hp < u.maxHp) {
      const inCity = cities.find(c => c.x === u.x && c.y === u.y && c.owner === u.owner);
      u.hp = Math.min(u.maxHp, u.hp + (inCity ? 15 : 5));
    }
  }

  // Reset moves
  for (const u of units) {
    u.movesLeft = UNIT_TYPES[u.type].moves;
  }

  turn++;
  selectedUnit = null;
  selectedCity = null;
  updateUI();
  render();
  checkWinCondition();
}

function checkWinCondition() {
  const playerCities = cities.filter(c => c.owner === 0);
  const aiCities = cities.filter(c => c.owner === 1);

  if (aiCities.length === 0 && turn > 1) {
    gameOver = true;
    showGameOver(true);
  } else if (playerCities.length === 0 && turn > 1) {
    gameOver = true;
    showGameOver(false);
  }
}

function showGameOver(won) {
  const overlay = document.getElementById('game-over-overlay');
  overlay.classList.add('show');
  document.getElementById('game-over-title').textContent = won ? 'èƒœåˆ©!' : 'å¤±è´¥!';
  document.getElementById('game-over-title').style.color = won ? '#2ecc71' : '#e74c3c';
  document.getElementById('game-over-msg').textContent = won
    ? `ç»è¿‡ ${turn} å›åˆçš„å¾æˆ˜, ä½ å¾æœäº†æ‰€æœ‰æ•Œæ–¹åŸå¸‚!`
    : `åœ¨ç¬¬ ${turn} å›åˆ, ä½ çš„æœ€åä¸€åº§åŸå¸‚é™·è½äº†...`;
}

// ============================================================
// Rendering
// ============================================================
function resizeCanvas() {
  const rect = wrapper.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  render();
}

function render() {
  const w = canvas.width, h = canvas.height;
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, w, h);

  const startTileX = Math.max(0, Math.floor(camX / TILE));
  const startTileY = Math.max(0, Math.floor(camY / TILE));
  const endTileX = Math.min(MAP_W - 1, Math.floor((camX + w) / TILE));
  const endTileY = Math.min(MAP_H - 1, Math.floor((camY + h) / TILE));

  // Draw terrain
  for (let ty = startTileY; ty <= endTileY; ty++) {
    for (let tx = startTileX; tx <= endTileX; tx++) {
      const sx = tx * TILE - camX;
      const sy = ty * TILE - camY;

      if (!explored[0][ty][tx]) {
        ctx.fillStyle = '#0a0a1a';
        ctx.fillRect(sx, sy, TILE, TILE);
        continue;
      }

      const vis = isVisible(0, tx, ty);
      const terrain = map[ty][tx];
      ctx.fillStyle = vis ? TERRAIN_COLORS[terrain] : TERRAIN_COLORS_DARK[terrain];
      ctx.fillRect(sx, sy, TILE, TILE);

      // Terrain detail
      if (vis) {
        ctx.globalAlpha = 0.15;
        if (terrain === T.FOREST) {
          ctx.fillStyle = '#000';
          ctx.font = '18px serif';
          ctx.fillText('ğŸŒ²', sx + 12, sy + 28);
        } else if (terrain === T.MOUNTAIN) {
          ctx.fillStyle = '#555';
          ctx.font = '16px serif';
          ctx.fillText('â›°', sx + 12, sy + 26);
        } else if (terrain === T.WATER) {
          ctx.fillStyle = '#fff';
          ctx.font = '12px serif';
          ctx.fillText('ã€°', sx + 10, sy + 24);
        }
        ctx.globalAlpha = 1;
      } else {
        // Fog tint
        ctx.fillStyle = 'rgba(0, 0, 20, 0.35)';
        ctx.fillRect(sx, sy, TILE, TILE);
      }

      // Grid lines
      ctx.strokeStyle = vis ? 'rgba(255,255,255,0.08)' : 'rgba(255,255,255,0.03)';
      ctx.strokeRect(sx, sy, TILE, TILE);
    }
  }

  // Draw cities
  for (const city of cities) {
    if (!explored[0][city.y][city.x]) continue;
    const vis = isVisible(0, city.x, city.y);
    if (!vis && city.owner === 1) continue;
    const sx = city.x * TILE - camX;
    const sy = city.y * TILE - camY;

    // City territory highlight
    ctx.fillStyle = city.owner === 0 ? 'rgba(52,152,219,0.12)' : 'rgba(231,76,60,0.12)';
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = city.x + dx, ny = city.y + dy;
        if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H) {
          ctx.fillRect(nx * TILE - camX, ny * TILE - camY, TILE, TILE);
        }
      }
    }

    // City icon
    const color = PLAYER_COLORS[city.owner];
    ctx.fillStyle = color;
    ctx.fillRect(sx + 4, sy + 4, TILE - 8, TILE - 8);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(city.population.toString(), sx + TILE/2, sy + TILE/2 - 2);
    ctx.font = '9px sans-serif';
    ctx.fillText(city.name, sx + TILE/2, sy + TILE/2 + 10);
    ctx.textAlign = 'left';

    // City HP bar
    if (city.hp < city.maxHp) {
      ctx.fillStyle = '#333';
      ctx.fillRect(sx + 4, sy + 1, TILE - 8, 3);
      ctx.fillStyle = city.hp > city.maxHp * 0.5 ? '#2ecc71' : '#e74c3c';
      ctx.fillRect(sx + 4, sy + 1, (TILE - 8) * (city.hp / city.maxHp), 3);
    }

    // Selection highlight
    if (selectedCity === city) {
      ctx.strokeStyle = '#f1c40f';
      ctx.lineWidth = 2;
      ctx.strokeRect(sx + 2, sy + 2, TILE - 4, TILE - 4);
      ctx.lineWidth = 1;
    }
  }

  // Draw units
  for (const unit of units) {
    if (!isVisible(0, unit.x, unit.y) && unit.owner === 1) continue;
    if (!explored[0][unit.y][unit.x]) continue;
    const sx = unit.x * TILE - camX;
    const sy = unit.y * TILE - camY;
    const uType = UNIT_TYPES[unit.type];

    // Unit background circle
    const color = PLAYER_COLORS[unit.owner];
    ctx.beginPath();
    ctx.arc(sx + TILE/2, sy + TILE/2, 14, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.8;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Unit symbol
    ctx.font = '16px serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.fillText(uType.symbol, sx + TILE/2, sy + TILE/2 + 5);
    ctx.textAlign = 'left';

    // HP bar
    if (unit.hp < unit.maxHp) {
      ctx.fillStyle = '#333';
      ctx.fillRect(sx + 6, sy + TILE - 6, TILE - 12, 3);
      const hpRatio = unit.hp / unit.maxHp;
      ctx.fillStyle = hpRatio > 0.5 ? '#2ecc71' : hpRatio > 0.25 ? '#f39c12' : '#e74c3c';
      ctx.fillRect(sx + 6, sy + TILE - 6, (TILE - 12) * hpRatio, 3);
    }

    // Fortified indicator
    if (unit.fortified) {
      ctx.fillStyle = '#2ecc71';
      ctx.font = '10px sans-serif';
      ctx.fillText('ğŸ›¡', sx + 2, sy + 12);
    }

    // Selection highlight
    if (selectedUnit === unit) {
      ctx.strokeStyle = '#f1c40f';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(sx + TILE/2, sy + TILE/2, 16, 0, Math.PI * 2);
      ctx.stroke();
      ctx.lineWidth = 1;

      // Show movement range
      if (unit.movesLeft > 0) {
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = unit.x + dx, ny = unit.y + dy;
            if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && getMoveCost(nx, ny) < Infinity) {
              const msx = nx * TILE - camX;
              const msy = ny * TILE - camY;
              ctx.fillStyle = 'rgba(241, 196, 15, 0.15)';
              ctx.fillRect(msx, msy, TILE, TILE);
              ctx.strokeStyle = 'rgba(241, 196, 15, 0.4)';
              ctx.strokeRect(msx + 1, msy + 1, TILE - 2, TILE - 2);
            }
          }
        }
      }
    }
  }

  renderMinimap();
}

function renderMinimap() {
  const mw = minimapCanvas.width;
  const mh = minimapCanvas.height;
  const scaleX = mw / MAP_W;
  const scaleY = mh / MAP_H;

  mctx.fillStyle = '#0a0a1a';
  mctx.fillRect(0, 0, mw, mh);

  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      if (!explored[0][y][x]) continue;
      mctx.fillStyle = TERRAIN_COLORS[map[y][x]];
      mctx.fillRect(x * scaleX, y * scaleY, scaleX + 0.5, scaleY + 0.5);
    }
  }

  // Cities
  for (const city of cities) {
    if (!explored[0][city.y][city.x]) continue;
    mctx.fillStyle = PLAYER_COLORS[city.owner];
    mctx.fillRect(city.x * scaleX - 1, city.y * scaleY - 1, 4, 4);
  }

  // Units (player only)
  for (const unit of units) {
    if (unit.owner !== 0) continue;
    mctx.fillStyle = '#fff';
    mctx.fillRect(unit.x * scaleX, unit.y * scaleY, 2, 2);
  }

  // Viewport rect
  const vx = camX / TILE * scaleX;
  const vy = camY / TILE * scaleY;
  const vw = canvas.width / TILE * scaleX;
  const vh = canvas.height / TILE * scaleY;
  mctx.strokeStyle = '#f1c40f';
  mctx.lineWidth = 1.5;
  mctx.strokeRect(vx, vy, vw, vh);
}

// ============================================================
// UI Updates
// ============================================================
function updateUI() {
  document.getElementById('turn-num').textContent = `å›åˆ: ${turn}`;
  document.getElementById('res-gold').textContent = gold[0];

  // Calculate gold rate
  let goldRate = 0;
  for (const c of cities) {
    if (c.owner === 0) goldRate += getCityYields(c).gold;
  }
  document.getElementById('res-gold-rate').textContent = `+${goldRate}`;
  document.getElementById('res-science').textContent = science[0];

  let totalPop = 0;
  for (const c of cities) {
    if (c.owner === 0) totalPop += c.population;
  }
  document.getElementById('res-pop').textContent = totalPop;

  updateInfoPanel();
}

function updateInfoPanel() {
  const panel = document.getElementById('info-content');

  if (selectedUnit && units.includes(selectedUnit)) {
    const u = selectedUnit;
    const uType = UNIT_TYPES[u.type];
    let html = `<div class="info-section">
      <h3 style="color:${PLAYER_COLORS[u.owner]}">${uType.symbol} ${uType.name} ${u.owner===0?'(æˆ‘æ–¹)':'(æ•Œæ–¹)'}</h3>
      <div class="info-row"><span class="label">ç”Ÿå‘½å€¼</span><span>${u.hp}/${u.maxHp}</span></div>
      <div class="health-bar"><div class="health-fill" style="width:${u.hp/u.maxHp*100}%;background:${u.hp/u.maxHp>0.5?'#2ecc71':'#e74c3c'}"></div></div>
      <div class="info-row"><span class="label">ç§»åŠ¨åŠ›</span><span>${u.movesLeft}/${uType.moves}</span></div>
      <div class="unit-moves-bar"><div class="unit-moves-fill" style="width:${u.movesLeft/uType.moves*100}%"></div></div>
      <div class="info-row"><span class="label">æ”»å‡»åŠ›</span><span>${uType.attack}</span></div>
      <div class="info-row"><span class="label">é˜²å¾¡åŠ›</span><span>${uType.defense}</span></div>
      <div class="info-row"><span class="label">ä½ç½®</span><span>(${u.x}, ${u.y})</span></div>
      <div class="info-row"><span class="label">åœ°å½¢</span><span>${TERRAIN_NAMES[map[u.y][u.x]]}</span></div>`;

    if (u.owner === 0) {
      html += `<div class="action-buttons">`;
      if (u.type === 'settler' && u.movesLeft > 0) {
        html += `<button class="action-btn" onclick="foundCity(selectedUnit);updateUI();render();">ğŸ™ å»ºç«‹åŸå¸‚</button>`;
      }
      if (u.type === 'warrior') {
        if (!u.fortified) {
          html += `<button class="action-btn" onclick="selectedUnit.fortified=true;selectedUnit.movesLeft=0;updateUI();render();">ğŸ›¡ é©»é˜² (é˜²å¾¡+30%)</button>`;
        } else {
          html += `<button class="action-btn" onclick="selectedUnit.fortified=false;updateUI();render();">ğŸš¶ è§£é™¤é©»é˜²</button>`;
        }
      }
      if (u.type === 'worker' && u.movesLeft > 0) {
        const terrain = map[u.y][u.x];
        if (terrain === T.FOREST) {
          html += `<button class="action-btn" onclick="map[selectedUnit.y][selectedUnit.x]=T.PLAINS;selectedUnit.movesLeft=0;notify('ä¼æœ¨å®Œæˆ!');updateUI();render();">ğŸª“ ç ä¼æ£®æ—</button>`;
        }
      }
      html += `<button class="action-btn" onclick="units=units.filter(u=>u!==selectedUnit);selectedUnit=null;updateUI();render();">âŒ è§£æ•£å•ä½</button>`;
      html += `</div>`;
    }
    html += `</div>`;
    panel.innerHTML = html;
  } else if (selectedCity && cities.includes(selectedCity)) {
    const c = selectedCity;
    const yields = getCityYields(c);
    const foodConsumption = c.population * 2;
    let html = `<div class="info-section">
      <h3 style="color:${PLAYER_COLORS[c.owner]}">ğŸ™ ${c.name} ${c.owner===0?'(æˆ‘æ–¹)':'(æ•Œæ–¹)'}</h3>
      <div class="info-row"><span class="label">äººå£</span><span>${c.population}</span></div>
      <div class="info-row"><span class="label">åŸå¸‚HP</span><span>${c.hp}/${c.maxHp}</span></div>
      <div class="health-bar"><div class="health-fill" style="width:${c.hp/c.maxHp*100}%;background:${c.hp/c.maxHp>0.5?'#2ecc71':'#e74c3c'}"></div></div>
      <div class="info-row"><span class="label">ğŸŒ¾ é£Ÿç‰©</span><span>+${yields.food} / æ¶ˆè€—${foodConsumption}</span></div>
      <div class="info-row"><span class="label">âš’ äº§èƒ½</span><span>+${yields.prod}</span></div>
      <div class="info-row"><span class="label">ğŸª™ é‡‘å¸</span><span>+${yields.gold}</span></div>
      <div class="info-row"><span class="label">é£Ÿç‰©å‚¨å¤‡</span><span>${c.food}/${c.foodNeeded}</span></div>
      <div class="city-build-progress"><div class="city-build-fill" style="width:${c.food/c.foodNeeded*100}%"></div></div>`;

    // Current build
    if (c.buildQueue) {
      const cost = getBuildCost(c.buildQueue);
      const name = c.buildQueue.type === 'unit'
        ? UNIT_TYPES[c.buildQueue.key].name
        : IMPROVEMENTS[c.buildQueue.key].name;
      const turnsLeft = Math.max(1, Math.ceil((cost - c.buildProgress) / Math.max(1, yields.prod)));
      html += `<div class="info-row" style="margin-top:8px"><span class="label">æ­£åœ¨å»ºé€ </span><span>${name}</span></div>
        <div class="info-row"><span class="label">è¿›åº¦</span><span>${c.buildProgress}/${cost} (~${turnsLeft}å›åˆ)</span></div>
        <div class="city-build-progress"><div class="city-build-fill" style="width:${c.buildProgress/cost*100}%"></div></div>`;
    }

    // Improvements
    if (c.improvements.length > 0) {
      html += `<div style="margin-top:8px;font-size:12px;color:#aaa;">å·²å»ºè®¾:</div>`;
      for (const imp of c.improvements) {
        html += `<div style="font-size:12px;color:#7fb3d8;padding:1px 0;">â€¢ ${IMPROVEMENTS[imp].name} (${IMPROVEMENTS[imp].desc})</div>`;
      }
    }

    // Build options (player only)
    if (c.owner === 0) {
      html += `<div style="margin-top:10px;font-size:12px;color:#aaa;border-top:1px solid #333;padding-top:6px;">è®­ç»ƒå•ä½:</div>
        <div class="action-buttons">`;
      for (const [key, ut] of Object.entries(UNIT_TYPES)) {
        const active = c.buildQueue && c.buildQueue.type === 'unit' && c.buildQueue.key === key;
        html += `<button class="action-btn" ${active ? 'style="border-color:#e94560;background:#1a3050"' : ''} onclick="setBuild(${c.id},'unit','${key}')">
          ${ut.symbol} ${ut.name} <span class="cost">(${ut.cost}âš’)</span></button>`;
      }
      html += `</div>
        <div style="margin-top:8px;font-size:12px;color:#aaa;">å»ºé€ è®¾æ–½:</div>
        <div class="action-buttons">`;
      for (const [key, imp] of Object.entries(IMPROVEMENTS)) {
        const built = c.improvements.includes(key);
        const active = c.buildQueue && c.buildQueue.type === 'improvement' && c.buildQueue.key === key;
        html += `<button class="action-btn" ${built?'disabled':''} ${active?'style="border-color:#e94560;background:#1a3050"':''}
          onclick="setBuild(${c.id},'improvement','${key}')">
          ${imp.name} <span class="cost">(${imp.cost}âš’) ${imp.desc}</span> ${built?'âœ…':''}</button>`;
      }
      html += `</div>`;
    }
    html += `</div>`;
    panel.innerHTML = html;
  } else {
    panel.innerHTML = `<p style="color:#888;font-size:13px;">ç‚¹å‡»åœ°å›¾ä¸Šçš„å•ä½æˆ–åŸå¸‚æŸ¥çœ‹è¯¦æƒ…</p>
      <div style="margin-top:12px;font-size:12px;color:#555;">
        <p>ğŸ“Œ æ“ä½œæç¤º:</p>
        <p>â€¢ ç‚¹å‡»é€‰æ‹©å•ä½/åŸå¸‚</p>
        <p>â€¢ é€‰ä¸­å•ä½åç‚¹å‡»ç›®æ ‡æ ¼ç§»åŠ¨</p>
        <p>â€¢ æ‹–æ‹½é¼ æ ‡ç§»åŠ¨åœ°å›¾</p>
        <p>â€¢ ç‚¹å‡»å°åœ°å›¾å¿«é€Ÿè·³è½¬</p>
        <p>â€¢ æ¶ˆç­æ‰€æœ‰æ•Œæ–¹åŸå¸‚å³å¯è·èƒœ</p>
      </div>`;
  }
}

function setBuild(cityId, type, key) {
  const city = cities.find(c => c.id === cityId);
  if (!city || city.owner !== 0) return;
  if (type === 'improvement' && city.improvements.includes(key)) return;
  city.buildQueue = { type, key };
  city.buildProgress = 0;
  const name = type === 'unit' ? UNIT_TYPES[key].name : IMPROVEMENTS[key].name;
  notify(`${city.name} å¼€å§‹å»ºé€ : ${name}`);
  updateInfoPanel();
}

// ============================================================
// Notifications
// ============================================================
function notify(msg) {
  const container = document.getElementById('notifications');
  const el = document.createElement('div');
  el.className = 'notification';
  el.textContent = msg;
  container.appendChild(el);
  setTimeout(() => {
    if (el.parentNode) el.parentNode.removeChild(el);
  }, 3200);
}

// ============================================================
// Input Handling
// ============================================================
let clickStartX, clickStartY, hasDragged;

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  hasDragged = false;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragCamStartX = camX;
  dragCamStartY = camY;
  clickStartX = e.clientX;
  clickStartY = e.clientY;
});

canvas.addEventListener('mousemove', (e) => {
  // Update coord display
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left + camX;
  const my = e.clientY - rect.top + camY;
  const tx = Math.floor(mx / TILE);
  const ty = Math.floor(my / TILE);
  if (tx >= 0 && tx < MAP_W && ty >= 0 && ty < MAP_H) {
    document.getElementById('coord-display').textContent = `åæ ‡: (${tx}, ${ty})`;
    if (explored[0][ty][tx]) {
      document.getElementById('terrain-display').textContent = `åœ°å½¢: ${TERRAIN_NAMES[map[ty][tx]]}`;
    } else {
      document.getElementById('terrain-display').textContent = 'åœ°å½¢: æœªæ¢ç´¢';
    }
  }

  if (isDragging) {
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) hasDragged = true;
    camX = dragCamStartX - dx;
    camY = dragCamStartY - dy;
    clampCamera();
    render();
  }
});

canvas.addEventListener('mouseup', (e) => {
  isDragging = false;
  if (!hasDragged) {
    handleClick(e);
  }
});

canvas.addEventListener('mouseleave', () => {
  isDragging = false;
});

function handleClick(e) {
  if (gameOver) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left + camX;
  const my = e.clientY - rect.top + camY;
  const tx = Math.floor(mx / TILE);
  const ty = Math.floor(my / TILE);

  if (tx < 0 || tx >= MAP_W || ty < 0 || ty >= MAP_H) return;
  if (!explored[0][ty][tx]) return;

  // If we have a selected unit with moves, try to move
  if (selectedUnit && selectedUnit.owner === 0 && selectedUnit.movesLeft > 0) {
    const dx = Math.abs(selectedUnit.x - tx);
    const dy = Math.abs(selectedUnit.y - ty);
    if (dx <= 1 && dy <= 1 && !(dx === 0 && dy === 0)) {
      if (moveUnit(selectedUnit, tx, ty)) {
        if (!units.includes(selectedUnit)) selectedUnit = null;
        updateUI();
        render();
        return;
      }
    }
  }

  // Try to select a player unit at this position
  const playerUnit = units.find(u => u.x === tx && u.y === ty && u.owner === 0);
  if (playerUnit) {
    selectedUnit = playerUnit;
    selectedCity = null;
    updateUI();
    render();
    return;
  }

  // Try to select a city at this position
  const city = cities.find(c => c.x === tx && c.y === ty);
  if (city) {
    selectedCity = city;
    selectedUnit = null;
    updateUI();
    render();
    return;
  }

  // Try to select visible enemy unit
  const enemyUnit = units.find(u => u.x === tx && u.y === ty && u.owner !== 0);
  if (enemyUnit && isVisible(0, tx, ty)) {
    selectedUnit = enemyUnit;
    selectedCity = null;
    updateUI();
    render();
    return;
  }

  // Deselect
  selectedUnit = null;
  selectedCity = null;
  updateUI();
  render();
}

// Minimap click
minimapCanvas.addEventListener('click', (e) => {
  const rect = minimapCanvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width;
  const my = (e.clientY - rect.top) / rect.height;
  camX = mx * CANVAS_PX_W - canvas.width / 2;
  camY = my * CANVAS_PX_H - canvas.height / 2;
  clampCamera();
  render();
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    endTurn();
  }
  if (e.key === 'f' && selectedUnit && selectedUnit.owner === 0 && selectedUnit.type === 'warrior') {
    selectedUnit.fortified = !selectedUnit.fortified;
    if (selectedUnit.fortified) selectedUnit.movesLeft = 0;
    updateUI();
    render();
  }
  if (e.key === 'b' && selectedUnit && selectedUnit.owner === 0 && selectedUnit.type === 'settler') {
    foundCity(selectedUnit);
    updateUI();
    render();
  }
});

// End turn button
document.getElementById('btn-end-turn').addEventListener('click', endTurn);

function clampCamera() {
  camX = Math.max(0, Math.min(CANVAS_PX_W - canvas.width, camX));
  camY = Math.max(0, Math.min(CANVAS_PX_H - canvas.height, camY));
}

// ============================================================
// Game Initialization
// ============================================================
function initGame() {
  generateMap();

  // Place player start
  const p1 = findStartPos();
  createCity(0, p1.x, p1.y, 'é•¿å®‰');
  createUnit(0, 'warrior', p1.x + 1, p1.y);

  // Place AI start
  const p2 = findStartPos(p1.x);
  createCity(1, p2.x, p2.y, 'ç½—é©¬');
  createUnit(1, 'warrior', p2.x + 1, p2.y);
  createUnit(1, 'warrior', p2.x, p2.y + 1);

  // Second AI city nearby (if possible)
  let placed2nd = false;
  for (let r = 4; r <= 8; r++) {
    for (let dy = -r; dy <= r; dy++) {
      for (let dx = -r; dx <= r; dx++) {
        const nx = p2.x + dx, ny = p2.y + dy;
        if (Math.abs(dx) + Math.abs(dy) >= 4 && nx >= 2 && nx < MAP_W-2 && ny >= 2 && ny < MAP_H-2) {
          if (isLand(nx, ny) && map[ny][nx] === T.PLAINS) {
            const nearCity = cities.find(c => Math.abs(c.x-nx) <= 2 && Math.abs(c.y-ny) <= 2);
            if (!nearCity) {
              createCity(1, nx, ny, 'é›…å…¸');
              createUnit(1, 'warrior', nx - 1, ny);
              placed2nd = true;
              break;
            }
          }
        }
      }
      if (placed2nd) break;
    }
    if (placed2nd) break;
  }

  // Reveal starting areas
  for (const c of cities) revealAround(c.owner, c.x, c.y, 4);
  for (const u of units) revealAround(u.owner, u.x, u.y, 3);

  // Center camera on player city
  const playerCity = cities.find(c => c.owner === 0);
  if (playerCity) {
    camX = playerCity.x * TILE - canvas.width / 2;
    camY = playerCity.y * TILE - canvas.height / 2;
  }
  clampCamera();

  updateUI();
  render();
  notify('æ¬¢è¿æ¥åˆ°æ–‡æ˜ä¹‹å…‰!');
  notify('è®­ç»ƒå†›é˜Ÿ, å»ºè®¾åŸå¸‚, å¾æœæ•Œäºº!');
}

// ============================================================
// Start
// ============================================================
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
initGame();
</script>
</body>
</html>
