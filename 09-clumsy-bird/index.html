<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>笨鸟先飞</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }
  #gameContainer {
    position: relative;
    border: 4px solid #2a2a4a;
    border-radius: 8px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), 0 0 60px rgba(78, 78, 150, 0.2);
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
</div>
<script>
(function() {
  'use strict';

  // ============================================================
  // CONFIGURATION
  // ============================================================
  const CFG = {
    WIDTH: 400,
    HEIGHT: 600,
    GRAVITY: 0.45,
    FLAP_FORCE: -7.5,
    TERMINAL_VEL: 10,
    BIRD_X: 80,
    BIRD_W: 34,
    BIRD_H: 26,
    PIPE_W: 52,
    PIPE_CAP_H: 24,
    PIPE_CAP_EXTRA: 4,
    PIPE_GAP: 140,
    PIPE_SPEED: 2.5,
    PIPE_SPAWN_DIST: 220,
    GROUND_H: 80,
    GROUND_SPEED: 2.5,
    CLOUD_COUNT: 4,
    SHAKE_DURATION: 300,
    SHAKE_INTENSITY: 8,
  };

  const PLAY_AREA_H = CFG.HEIGHT - CFG.GROUND_H;

  // ============================================================
  // CANVAS SETUP
  // ============================================================
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = CFG.WIDTH;
  canvas.height = CFG.HEIGHT;

  // Scale canvas for retina / high DPI
  const container = document.getElementById('gameContainer');
  function resizeCanvas() {
    const maxW = window.innerWidth - 20;
    const maxH = window.innerHeight - 20;
    const scale = Math.min(maxW / CFG.WIDTH, maxH / CFG.HEIGHT, 1.5);
    canvas.style.width = Math.floor(CFG.WIDTH * scale) + 'px';
    canvas.style.height = Math.floor(CFG.HEIGHT * scale) + 'px';
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // ============================================================
  // WEB AUDIO API - SOUND EFFECTS
  // ============================================================
  let audioCtx = null;

  function initAudio() {
    if (!audioCtx) {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        audioCtx = null;
      }
    }
  }

  function playSound(type) {
    if (!audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;

      switch (type) {
        case 'flap':
          osc.type = 'square';
          osc.frequency.setValueAtTime(440, now);
          osc.frequency.exponentialRampToValueAtTime(600, now + 0.06);
          osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);
          gain.gain.setValueAtTime(0.12, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
          osc.start(now);
          osc.stop(now + 0.12);
          break;
        case 'score':
          osc.type = 'square';
          osc.frequency.setValueAtTime(523, now);
          osc.frequency.setValueAtTime(659, now + 0.07);
          osc.frequency.setValueAtTime(784, now + 0.14);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
          osc.start(now);
          osc.stop(now + 0.25);
          break;
        case 'hit':
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(200, now);
          osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
          gain.gain.setValueAtTime(0.2, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
          osc.start(now);
          osc.stop(now + 0.3);
          break;
        case 'die':
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(400, now);
          osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
          gain.gain.setValueAtTime(0.15, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
          osc.start(now);
          osc.stop(now + 0.5);
          break;
      }
    } catch (e) {}
  }

  // ============================================================
  // GAME STATE
  // ============================================================
  const STATE = {
    MENU: 0,
    PLAYING: 1,
    DYING: 2,
    GAMEOVER: 3,
  };

  let state = STATE.MENU;
  let score = 0;
  let bestScore = parseInt(localStorage.getItem('clumsy_bird_best') || '0', 10);

  // Bird
  let bird = {
    x: CFG.BIRD_X,
    y: PLAY_AREA_H / 2,
    vel: 0,
    rotation: 0,
    wingFrame: 0,
    wingTimer: 0,
    bobTimer: 0,
  };

  // Pipes
  let pipes = [];
  let pipeTimer = 0;

  // Ground scroll offset
  let groundOffset = 0;

  // Clouds
  let clouds = [];
  for (let i = 0; i < CFG.CLOUD_COUNT; i++) {
    clouds.push({
      x: Math.random() * CFG.WIDTH,
      y: 30 + Math.random() * 120,
      w: 50 + Math.random() * 60,
      speed: 0.3 + Math.random() * 0.5,
    });
  }

  // Stars (for night sky)
  let stars = [];
  for (let i = 0; i < 40; i++) {
    stars.push({
      x: Math.random() * CFG.WIDTH,
      y: Math.random() * (PLAY_AREA_H - 60),
      twinkle: Math.random() * Math.PI * 2,
      size: 1 + Math.random() * 1.5,
    });
  }

  // Screen shake
  let shakeTimer = 0;
  let shakeOffsetX = 0;
  let shakeOffsetY = 0;

  // Day/night cycle
  let dayNightProgress = 0; // 0 = day, 1 = full night

  // Death animation
  let deathFallDone = false;

  // Score flash
  let scoreFlash = 0;

  // ============================================================
  // HELPER: PIXEL ART DRAWING
  // ============================================================
  function drawPixelRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
  }

  // ============================================================
  // DRAW: SKY BACKGROUND (with day/night cycle)
  // ============================================================
  function lerpColor(c1, c2, t) {
    const r1 = parseInt(c1.slice(1, 3), 16);
    const g1 = parseInt(c1.slice(3, 5), 16);
    const b1 = parseInt(c1.slice(5, 7), 16);
    const r2 = parseInt(c2.slice(1, 3), 16);
    const g2 = parseInt(c2.slice(3, 5), 16);
    const b2 = parseInt(c2.slice(5, 7), 16);
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function drawSky() {
    const dayTop = '#4ec0ca';
    const dayBot = '#e0f0e0';
    const nightTop = '#0c1445';
    const nightBot = '#1a2366';

    const topColor = lerpColor(dayTop, nightTop, dayNightProgress);
    const botColor = lerpColor(dayBot, nightBot, dayNightProgress);

    const grad = ctx.createLinearGradient(0, 0, 0, PLAY_AREA_H);
    grad.addColorStop(0, topColor);
    grad.addColorStop(1, botColor);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CFG.WIDTH, PLAY_AREA_H);
  }

  // ============================================================
  // DRAW: STARS (night)
  // ============================================================
  function drawStars(dt) {
    if (dayNightProgress < 0.2) return;
    const alpha = Math.min(1, (dayNightProgress - 0.2) / 0.3);
    for (const s of stars) {
      s.twinkle += dt * 3;
      const a = alpha * (0.4 + 0.6 * Math.abs(Math.sin(s.twinkle)));
      ctx.fillStyle = `rgba(255, 255, 230, ${a})`;
      ctx.fillRect(Math.floor(s.x), Math.floor(s.y), Math.ceil(s.size), Math.ceil(s.size));
    }
  }

  // ============================================================
  // DRAW: CLOUDS
  // ============================================================
  function drawClouds() {
    const alpha = 1 - dayNightProgress * 0.6;
    ctx.globalAlpha = alpha;
    for (const c of clouds) {
      ctx.fillStyle = '#ffffff';
      // Pixel-art cloud shape
      const cx = Math.floor(c.x);
      const cy = Math.floor(c.y);
      const cw = Math.floor(c.w);
      const ch = Math.floor(cw * 0.4);
      // Main body
      drawPixelRect(cx + cw * 0.1, cy + ch * 0.3, cw * 0.8, ch * 0.5, '#ffffff');
      // Top bumps
      drawPixelRect(cx + cw * 0.2, cy, cw * 0.25, ch * 0.5, '#ffffff');
      drawPixelRect(cx + cw * 0.45, cy + ch * 0.1, cw * 0.3, ch * 0.4, '#ffffff');
      // Shadow
      drawPixelRect(cx + cw * 0.15, cy + ch * 0.6, cw * 0.7, ch * 0.25, '#e8e8e8');
    }
    ctx.globalAlpha = 1;
  }

  function updateClouds() {
    for (const c of clouds) {
      c.x -= c.speed;
      if (c.x + c.w < 0) {
        c.x = CFG.WIDTH + 10;
        c.y = 30 + Math.random() * 120;
        c.w = 50 + Math.random() * 60;
      }
    }
  }

  // ============================================================
  // DRAW: GROUND
  // ============================================================
  function drawGround() {
    const gy = PLAY_AREA_H;
    // Grass top strip
    drawPixelRect(0, gy, CFG.WIDTH, 6, '#5bba3e');
    // Grass detail pixels
    for (let x = 0; x < CFG.WIDTH; x += 8) {
      const offset = (x + Math.floor(groundOffset)) % 16;
      if (offset < 8) {
        drawPixelRect(x, gy - 2, 4, 2, '#5bba3e');
        drawPixelRect(x, gy, 4, 3, '#4aab30');
      }
    }
    // Dirt
    drawPixelRect(0, gy + 6, CFG.WIDTH, CFG.GROUND_H - 6, '#deb887');
    // Dirt texture stripes
    for (let y = gy + 12; y < CFG.HEIGHT; y += 10) {
      drawPixelRect(0, y, CFG.WIDTH, 2, '#d4a86a');
    }
    // Scrolling pebble pattern
    for (let x = -20; x < CFG.WIDTH + 20; x += 30) {
      const px = ((x - groundOffset % 30) + CFG.WIDTH + 30) % (CFG.WIDTH + 40) - 20;
      drawPixelRect(px, gy + 10, 4, 3, '#c49660');
      drawPixelRect(px + 12, gy + 18, 3, 2, '#c49660');
    }
  }

  // ============================================================
  // DRAW: PIPE
  // ============================================================
  function drawPipe(px, topH, botY) {
    const capW = CFG.PIPE_W + CFG.PIPE_CAP_EXTRA * 2;
    const capX = px - CFG.PIPE_CAP_EXTRA;

    // -- Top pipe --
    // Body
    ctx.fillStyle = '#73bf2e';
    ctx.fillRect(Math.floor(px), 0, CFG.PIPE_W, topH - CFG.PIPE_CAP_H);
    // Highlight on body
    ctx.fillStyle = '#8cd93e';
    ctx.fillRect(Math.floor(px) + 3, 0, 6, topH - CFG.PIPE_CAP_H);
    // Shadow on body
    ctx.fillStyle = '#5a9e1e';
    ctx.fillRect(Math.floor(px) + CFG.PIPE_W - 8, 0, 8, topH - CFG.PIPE_CAP_H);

    // Cap
    ctx.fillStyle = '#73bf2e';
    ctx.fillRect(Math.floor(capX), topH - CFG.PIPE_CAP_H, capW, CFG.PIPE_CAP_H);
    // Cap highlight
    ctx.fillStyle = '#8cd93e';
    ctx.fillRect(Math.floor(capX) + 3, topH - CFG.PIPE_CAP_H, 6, CFG.PIPE_CAP_H);
    // Cap shadow
    ctx.fillStyle = '#5a9e1e';
    ctx.fillRect(Math.floor(capX) + capW - 8, topH - CFG.PIPE_CAP_H, 8, CFG.PIPE_CAP_H);
    // Cap border
    ctx.fillStyle = '#3a7a10';
    ctx.fillRect(Math.floor(capX), topH - CFG.PIPE_CAP_H, capW, 3);
    ctx.fillRect(Math.floor(capX), topH - 3, capW, 3);

    // -- Bottom pipe --
    const botH = PLAY_AREA_H - botY;
    // Body
    ctx.fillStyle = '#73bf2e';
    ctx.fillRect(Math.floor(px), botY + CFG.PIPE_CAP_H, CFG.PIPE_W, botH - CFG.PIPE_CAP_H);
    // Highlight
    ctx.fillStyle = '#8cd93e';
    ctx.fillRect(Math.floor(px) + 3, botY + CFG.PIPE_CAP_H, 6, botH - CFG.PIPE_CAP_H);
    // Shadow
    ctx.fillStyle = '#5a9e1e';
    ctx.fillRect(Math.floor(px) + CFG.PIPE_W - 8, botY + CFG.PIPE_CAP_H, 8, botH - CFG.PIPE_CAP_H);

    // Cap
    ctx.fillStyle = '#73bf2e';
    ctx.fillRect(Math.floor(capX), botY, capW, CFG.PIPE_CAP_H);
    ctx.fillStyle = '#8cd93e';
    ctx.fillRect(Math.floor(capX) + 3, botY, 6, CFG.PIPE_CAP_H);
    ctx.fillStyle = '#5a9e1e';
    ctx.fillRect(Math.floor(capX) + capW - 8, botY, 8, CFG.PIPE_CAP_H);
    ctx.fillStyle = '#3a7a10';
    ctx.fillRect(Math.floor(capX), botY, capW, 3);
    ctx.fillRect(Math.floor(capX), botY + CFG.PIPE_CAP_H - 3, capW, 3);
  }

  // ============================================================
  // DRAW: BIRD
  // ============================================================
  function drawBird(bx, by, rot, wingFrame) {
    ctx.save();
    ctx.translate(Math.floor(bx + CFG.BIRD_W / 2), Math.floor(by + CFG.BIRD_H / 2));
    ctx.rotate(rot);

    const ox = -CFG.BIRD_W / 2;
    const oy = -CFG.BIRD_H / 2;

    // Body - main yellow
    drawPixelRect(ox + 4, oy + 6, 22, 14, '#f5c842');
    // Body bottom (slightly darker)
    drawPixelRect(ox + 6, oy + 16, 18, 4, '#e8b530');
    // Body top
    drawPixelRect(ox + 6, oy + 4, 18, 4, '#f5c842');

    // Belly (lighter)
    drawPixelRect(ox + 8, oy + 12, 12, 8, '#fae07a');

    // Head top curve
    drawPixelRect(ox + 8, oy + 2, 14, 4, '#f5c842');
    drawPixelRect(ox + 10, oy, 10, 4, '#f5d862');

    // Wing
    if (wingFrame === 0) {
      // Wing up
      drawPixelRect(ox + 2, oy + 6, 10, 8, '#e8b530');
      drawPixelRect(ox + 4, oy + 4, 8, 4, '#d4a020');
      drawPixelRect(ox, oy + 8, 4, 4, '#d4a020');
    } else if (wingFrame === 1) {
      // Wing middle
      drawPixelRect(ox + 2, oy + 10, 10, 6, '#e8b530');
      drawPixelRect(ox, oy + 12, 4, 4, '#d4a020');
    } else {
      // Wing down
      drawPixelRect(ox + 2, oy + 14, 10, 6, '#e8b530');
      drawPixelRect(ox, oy + 16, 6, 4, '#d4a020');
    }

    // Eye (white)
    drawPixelRect(ox + 18, oy + 4, 8, 8, '#ffffff');
    // Eye pupil
    drawPixelRect(ox + 22, oy + 6, 4, 4, '#222222');
    // Eye highlight
    drawPixelRect(ox + 22, oy + 4, 2, 2, '#ffffff');

    // Beak top
    drawPixelRect(ox + 24, oy + 10, 10, 4, '#f57542');
    // Beak bottom
    drawPixelRect(ox + 24, oy + 14, 8, 3, '#e85d30');

    // Tail feathers
    drawPixelRect(ox, oy + 8, 4, 3, '#e8a030');
    drawPixelRect(ox - 2, oy + 6, 4, 3, '#d49020');

    ctx.restore();
  }

  // ============================================================
  // DRAW: SCORE
  // ============================================================
  function drawScore() {
    ctx.save();
    ctx.font = 'bold 48px "Microsoft YaHei", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const flash = Math.min(1, scoreFlash * 2);
    const scale = 1 + flash * 0.2;

    ctx.save();
    ctx.translate(CFG.WIDTH / 2, 50);
    ctx.scale(scale, scale);

    // Outline
    ctx.fillStyle = '#000000';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 6;
    ctx.strokeText(score, 0, 0);
    // White fill
    ctx.fillStyle = '#ffffff';
    ctx.fillText(score, 0, 0);

    ctx.restore();
    ctx.restore();
  }

  // ============================================================
  // DRAW: MEDAL
  // ============================================================
  function getMedalInfo(s) {
    if (s >= 40) return { color: '#ffd700', label: '金牌', shadow: '#b8960f' };
    if (s >= 20) return { color: '#c0c0c0', label: '银牌', shadow: '#808080' };
    if (s >= 10) return { color: '#cd7f32', label: '铜牌', shadow: '#8b5a20' };
    return null;
  }

  function drawMedal(x, y, medal) {
    // Medal circle
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fillStyle = medal.shadow;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 1, y - 1, 20, 0, Math.PI * 2);
    ctx.fillStyle = medal.color;
    ctx.fill();
    // Star on medal
    ctx.font = 'bold 18px sans-serif';
    ctx.fillStyle = medal.shadow;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('\u2605', x, y + 1);
    // Label
    ctx.font = 'bold 14px "Microsoft YaHei", sans-serif';
    ctx.fillStyle = medal.color;
    ctx.fillText(medal.label, x, y + 36);
  }

  // ============================================================
  // DRAW: START SCREEN
  // ============================================================
  function drawStartScreen() {
    // Title
    ctx.save();
    ctx.font = 'bold 52px "Microsoft YaHei", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Shadow
    ctx.fillStyle = '#2a6e10';
    ctx.fillText('笨鸟先飞', CFG.WIDTH / 2 + 3, 130 + 3);
    // Main
    ctx.fillStyle = '#fae07a';
    ctx.strokeStyle = '#c87020';
    ctx.lineWidth = 4;
    ctx.strokeText('笨鸟先飞', CFG.WIDTH / 2, 130);
    ctx.fillText('笨鸟先飞', CFG.WIDTH / 2, 130);

    // Bobbing bird
    const bobY = Math.sin(bird.bobTimer) * 10;
    drawBird(CFG.WIDTH / 2 - CFG.BIRD_W / 2, 240 + bobY, 0, Math.floor(bird.wingTimer) % 3);

    // Instructions
    ctx.font = 'bold 24px "Microsoft YaHei", sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.strokeText('点击开始', CFG.WIDTH / 2, 360);
    ctx.fillText('点击开始', CFG.WIDTH / 2, 360);

    ctx.font = '16px "Microsoft YaHei", sans-serif';
    ctx.fillStyle = '#e0e0e0';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    const hintText = '点击屏幕 / 按空格键 飞行';
    ctx.strokeText(hintText, CFG.WIDTH / 2, 400);
    ctx.fillText(hintText, CFG.WIDTH / 2, 400);

    // Best score
    if (bestScore > 0) {
      ctx.font = '18px "Microsoft YaHei", sans-serif';
      ctx.fillStyle = '#fae07a';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      const bestText = '\u6700\u9AD8\u5206: ' + bestScore;
      ctx.strokeText(bestText, CFG.WIDTH / 2, 450);
      ctx.fillText(bestText, CFG.WIDTH / 2, 450);
    }

    ctx.restore();
  }

  // ============================================================
  // DRAW: GAME OVER SCREEN
  // ============================================================
  let gameOverAlpha = 0;

  function drawGameOverScreen() {
    ctx.save();

    gameOverAlpha = Math.min(1, gameOverAlpha + 0.03);
    ctx.globalAlpha = gameOverAlpha;

    // Overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
    ctx.fillRect(0, 0, CFG.WIDTH, CFG.HEIGHT);

    // Panel
    const pw = 280;
    const ph = 260;
    const px = (CFG.WIDTH - pw) / 2;
    const py = 140;

    // Panel bg
    ctx.fillStyle = '#ded895';
    ctx.fillRect(px, py, pw, ph);
    // Panel border
    ctx.strokeStyle = '#5a4a30';
    ctx.lineWidth = 4;
    ctx.strokeRect(px, py, pw, ph);
    // Inner border
    ctx.strokeStyle = '#8b7a50';
    ctx.lineWidth = 2;
    ctx.strokeRect(px + 6, py + 6, pw - 12, ph - 12);

    // "Game Over" text
    ctx.font = 'bold 36px "Microsoft YaHei", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#c83030';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.strokeText('游戏结束', CFG.WIDTH / 2, py - 20);
    ctx.fillText('游戏结束', CFG.WIDTH / 2, py - 20);

    // Score
    ctx.font = 'bold 18px "Microsoft YaHei", sans-serif';
    ctx.fillStyle = '#5a4a30';
    ctx.textAlign = 'left';
    ctx.fillText('分数', px + 30, py + 50);
    ctx.textAlign = 'right';
    ctx.fillText(score, px + pw - 30, py + 50);

    // Best
    ctx.textAlign = 'left';
    ctx.fillText('最高分', px + 30, py + 90);
    ctx.textAlign = 'right';
    const isNewBest = score >= bestScore && score > 0;
    if (isNewBest) {
      ctx.fillStyle = '#e8a030';
      ctx.fillText(bestScore + ' \u2605', px + pw - 30, py + 90);
    } else {
      ctx.fillText(bestScore, px + pw - 30, py + 90);
    }

    // Medal
    const medal = getMedalInfo(score);
    if (medal) {
      drawMedal(px + pw / 2, py + 150, medal);
    }

    // Restart button
    const bw = 180;
    const bh = 44;
    const bx = (CFG.WIDTH - bw) / 2;
    const by = py + ph + 20;

    // Button shadow
    ctx.fillStyle = '#3a7a10';
    ctx.fillRect(bx + 2, by + 2, bw, bh);
    // Button bg
    ctx.fillStyle = '#5bba3e';
    ctx.fillRect(bx, by, bw, bh);
    // Button highlight
    ctx.fillStyle = '#73d450';
    ctx.fillRect(bx, by, bw, 4);
    // Button text
    ctx.font = 'bold 22px "Microsoft YaHei", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#2a6e10';
    ctx.lineWidth = 2;
    ctx.strokeText('重新开始', bx + bw / 2, by + bh / 2);
    ctx.fillText('重新开始', bx + bw / 2, by + bh / 2);

    ctx.restore();
  }

  // ============================================================
  // GAME LOGIC
  // ============================================================
  function resetGame() {
    bird.y = PLAY_AREA_H / 2;
    bird.vel = 0;
    bird.rotation = 0;
    bird.wingFrame = 0;
    bird.wingTimer = 0;
    pipes = [];
    pipeTimer = 0;
    score = 0;
    scoreFlash = 0;
    groundOffset = 0;
    shakeTimer = 0;
    deathFallDone = false;
    gameOverAlpha = 0;
    dayNightProgress = 0;
  }

  function flap() {
    if (state === STATE.MENU) {
      initAudio();
      resetGame();
      state = STATE.PLAYING;
      bird.vel = CFG.FLAP_FORCE;
      playSound('flap');
      return;
    }
    if (state === STATE.PLAYING) {
      bird.vel = CFG.FLAP_FORCE;
      bird.wingFrame = 0;
      bird.wingTimer = 0;
      playSound('flap');
      return;
    }
    if (state === STATE.GAMEOVER) {
      resetGame();
      state = STATE.MENU;
      return;
    }
  }

  function spawnPipe() {
    const minTop = 60;
    const maxTop = PLAY_AREA_H - CFG.PIPE_GAP - 60;
    const topH = minTop + Math.random() * (maxTop - minTop);
    pipes.push({
      x: CFG.WIDTH + 10,
      topH: topH,
      botY: topH + CFG.PIPE_GAP,
      scored: false,
    });
  }

  function checkCollision() {
    const bx = bird.x + 4;
    const by = bird.y + 4;
    const bw = CFG.BIRD_W - 8;
    const bh = CFG.BIRD_H - 8;

    // Ground
    if (by + bh >= PLAY_AREA_H) return true;
    // Ceiling
    if (by <= 0) return true;

    for (const p of pipes) {
      const capX = p.x - CFG.PIPE_CAP_EXTRA;
      const capW = CFG.PIPE_W + CFG.PIPE_CAP_EXTRA * 2;

      // Top pipe body
      if (bx + bw > p.x && bx < p.x + CFG.PIPE_W && by < p.topH - CFG.PIPE_CAP_H) return true;
      // Top pipe cap
      if (bx + bw > capX && bx < capX + capW && by < p.topH && by + bh > p.topH - CFG.PIPE_CAP_H) return true;

      // Bottom pipe body
      if (bx + bw > p.x && bx < p.x + CFG.PIPE_W && by + bh > p.botY + CFG.PIPE_CAP_H) return true;
      // Bottom pipe cap
      if (bx + bw > capX && bx < capX + capW && by + bh > p.botY && by < p.botY + CFG.PIPE_CAP_H) return true;
    }

    return false;
  }

  function die() {
    state = STATE.DYING;
    playSound('hit');
    setTimeout(() => playSound('die'), 200);
    shakeTimer = CFG.SHAKE_DURATION;

    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('clumsy_bird_best', bestScore.toString());
    }
  }

  // ============================================================
  // UPDATE
  // ============================================================
  function update(dt) {
    const dtSec = dt / 16.67; // normalize to ~60fps

    // Wing animation timer
    bird.wingTimer += dt * 0.008;

    // Score flash decay
    if (scoreFlash > 0) scoreFlash -= dt * 0.003;

    // Screen shake
    if (shakeTimer > 0) {
      shakeTimer -= dt;
      const intensity = (shakeTimer / CFG.SHAKE_DURATION) * CFG.SHAKE_INTENSITY;
      shakeOffsetX = (Math.random() - 0.5) * intensity * 2;
      shakeOffsetY = (Math.random() - 0.5) * intensity * 2;
    } else {
      shakeOffsetX = 0;
      shakeOffsetY = 0;
    }

    if (state === STATE.MENU) {
      bird.bobTimer += dt * 0.004;
      bird.wingTimer += dt * 0.004;
      updateClouds();
      groundOffset = (groundOffset + CFG.GROUND_SPEED * dtSec) % 600;
      return;
    }

    if (state === STATE.PLAYING) {
      // Day/night cycle
      dayNightProgress = Math.min(1, score / 50);

      // Gravity
      bird.vel += CFG.GRAVITY * dtSec;
      if (bird.vel > CFG.TERMINAL_VEL) bird.vel = CFG.TERMINAL_VEL;
      bird.y += bird.vel * dtSec;

      // Bird rotation based on velocity
      const targetRot = bird.vel > 0
        ? Math.min(Math.PI / 3, bird.vel * 0.08)
        : Math.max(-Math.PI / 6, bird.vel * 0.05);
      bird.rotation += (targetRot - bird.rotation) * 0.15;

      // Wing animation: flap faster when going up
      bird.wingFrame = Math.floor(bird.wingTimer * 3) % 3;

      // Ground scroll
      groundOffset = (groundOffset + CFG.GROUND_SPEED * dtSec) % 600;

      // Clouds
      updateClouds();

      // Pipes
      pipeTimer += CFG.PIPE_SPEED * dtSec;
      if (pipeTimer >= CFG.PIPE_SPAWN_DIST) {
        spawnPipe();
        pipeTimer = 0;
      }

      for (let i = pipes.length - 1; i >= 0; i--) {
        pipes[i].x -= CFG.PIPE_SPEED * dtSec;

        // Score
        if (!pipes[i].scored && pipes[i].x + CFG.PIPE_W / 2 < bird.x) {
          pipes[i].scored = true;
          score++;
          scoreFlash = 1;
          playSound('score');
        }

        // Remove off-screen pipes
        if (pipes[i].x + CFG.PIPE_W + CFG.PIPE_CAP_EXTRA < -10) {
          pipes.splice(i, 1);
        }
      }

      // Collision
      if (checkCollision()) {
        die();
      }

      return;
    }

    if (state === STATE.DYING) {
      // Bird falls down
      bird.vel += CFG.GRAVITY * 1.2 * dtSec;
      if (bird.vel > CFG.TERMINAL_VEL) bird.vel = CFG.TERMINAL_VEL;
      bird.y += bird.vel * dtSec;
      bird.rotation += 0.1 * dtSec;
      if (bird.rotation > Math.PI / 2) bird.rotation = Math.PI / 2;

      if (bird.y + CFG.BIRD_H >= PLAY_AREA_H) {
        bird.y = PLAY_AREA_H - CFG.BIRD_H;
        bird.vel = 0;
        if (!deathFallDone) {
          deathFallDone = true;
          setTimeout(() => {
            state = STATE.GAMEOVER;
          }, 400);
        }
      }
      return;
    }
  }

  // ============================================================
  // RENDER
  // ============================================================
  function render() {
    ctx.save();
    ctx.translate(shakeOffsetX, shakeOffsetY);

    // Sky
    drawSky();

    // Stars
    drawStars(16);

    // Clouds
    drawClouds();

    // Pipes
    for (const p of pipes) {
      drawPipe(p.x, p.topH, p.botY);
    }

    // Ground
    drawGround();

    // Bird
    drawBird(bird.x, bird.y, bird.rotation, bird.wingFrame);

    // Score (in-game)
    if (state === STATE.PLAYING) {
      drawScore();
    }

    ctx.restore(); // end shake transform

    // UI overlays (not shaken)
    if (state === STATE.MENU) {
      drawStartScreen();
    }

    if (state === STATE.GAMEOVER) {
      drawGameOverScreen();
    }
  }

  // ============================================================
  // GAME LOOP
  // ============================================================
  let lastTime = 0;

  function gameLoop(timestamp) {
    const dt = Math.min(timestamp - lastTime, 33.33); // cap at ~30fps min
    lastTime = timestamp;

    update(dt);
    render();

    requestAnimationFrame(gameLoop);
  }

  requestAnimationFrame(function(ts) {
    lastTime = ts;
    requestAnimationFrame(gameLoop);
  });

  // ============================================================
  // INPUT HANDLING
  // ============================================================
  function handleInput(e) {
    if (e) e.preventDefault();
    flap();
  }

  canvas.addEventListener('mousedown', handleInput);
  canvas.addEventListener('touchstart', handleInput, { passive: false });

  document.addEventListener('keydown', function(e) {
    if (e.code === 'Space' || e.key === ' ') {
      e.preventDefault();
      flap();
    }
  });

  // Prevent scroll on mobile
  document.addEventListener('touchmove', function(e) {
    e.preventDefault();
  }, { passive: false });

})();
</script>
</body>
</html>
