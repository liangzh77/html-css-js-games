<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>国际象棋</title>
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

body {
  min-height: 100vh;
  background: linear-gradient(135deg, #1a0e0a 0%, #2d1810 30%, #1a0e0a 60%, #2d1810 100%);
  font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
  color: #e8d5b0;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow-x: hidden;
}

h1 {
  font-size: 2.4rem;
  margin: 18px 0 6px;
  text-shadow: 0 2px 8px rgba(0,0,0,.6);
  letter-spacing: 8px;
  color: #f0d9a0;
}

/* ---------- layout ---------- */
#app {
  display: flex;
  gap: 24px;
  align-items: flex-start;
  justify-content: center;
  flex-wrap: wrap;
  padding: 0 12px 30px;
  max-width: 1200px;
  width: 100%;
}

/* ---------- side panels ---------- */
.side-panel {
  width: 220px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  flex-shrink: 0;
}

/* captured pieces */
.captured-box {
  background: rgba(30,18,10,.85);
  border: 1px solid #5a3a20;
  border-radius: 10px;
  padding: 12px;
  min-height: 80px;
}
.captured-box h3 {
  font-size: .85rem;
  color: #b89860;
  margin-bottom: 6px;
  border-bottom: 1px solid #5a3a2044;
  padding-bottom: 4px;
}
.captured-pieces {
  display: flex;
  flex-wrap: wrap;
  gap: 2px;
  font-size: 1.5rem;
  line-height: 1;
}

/* move history */
#history-box {
  background: rgba(30,18,10,.85);
  border: 1px solid #5a3a20;
  border-radius: 10px;
  padding: 12px;
  max-height: 420px;
  overflow-y: auto;
}
#history-box h3 {
  font-size: .85rem;
  color: #b89860;
  margin-bottom: 6px;
  border-bottom: 1px solid #5a3a2044;
  padding-bottom: 4px;
}
#history-list {
  font-size: .82rem;
  line-height: 1.7;
  color: #d4c4a0;
}
.history-row { display: flex; gap: 6px; }
.history-num { color: #8a7a60; min-width: 28px; text-align: right; }
.history-white, .history-black { min-width: 68px; cursor: pointer; padding: 0 3px; border-radius: 3px; }
.history-white:hover, .history-black:hover { background: rgba(255,255,255,.08); }

#history-box::-webkit-scrollbar { width: 6px; }
#history-box::-webkit-scrollbar-track { background: transparent; }
#history-box::-webkit-scrollbar-thumb { background: #5a3a2088; border-radius: 3px; }

/* ---------- board wrapper ---------- */
#board-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

/* status bar */
#status-bar {
  font-size: 1.1rem;
  min-height: 32px;
  text-align: center;
  color: #f0d9a0;
  text-shadow: 0 1px 4px rgba(0,0,0,.5);
}

/* 3D wrapper */
#board-perspective {
  perspective: 900px;
  perspective-origin: 50% 40%;
}

#board-3d {
  transform: rotateX(18deg);
  transform-style: preserve-3d;
  transition: transform .4s;
}

/* board grid */
#board {
  display: grid;
  grid-template-columns: repeat(8, 72px);
  grid-template-rows: repeat(8, 72px);
  border: 6px solid #3e2210;
  border-radius: 4px;
  box-shadow:
    0 8px 30px rgba(0,0,0,.7),
    inset 0 0 12px rgba(0,0,0,.3),
    0 2px 0 #5a3a20;
  position: relative;
}

/* rank / file labels */
.board-labels-file, .board-labels-rank {
  display: flex;
  font-size: .75rem;
  color: #8a7a60;
  user-select: none;
}
.board-labels-file {
  justify-content: space-around;
  width: 576px;
  margin-left: 6px;
  margin-top: 2px;
}
.board-labels-rank {
  position: absolute;
  flex-direction: column;
  justify-content: space-around;
  height: 576px;
  left: -18px;
  top: 6px;
  text-align: center;
}

/* square */
.square {
  width: 72px;
  height: 72px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
  transition: background .15s;
  user-select: none;
}

/* wood textures via gradients */
.square-light {
  background:
    repeating-linear-gradient(90deg, transparent, transparent 3px, rgba(180,140,80,.08) 3px, rgba(180,140,80,.08) 4px),
    repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(160,120,60,.06) 8px, rgba(160,120,60,.06) 9px),
    linear-gradient(135deg, #e8c882 0%, #d4b06a 50%, #e0c078 100%);
}
.square-dark {
  background:
    repeating-linear-gradient(90deg, transparent, transparent 3px, rgba(60,30,10,.10) 3px, rgba(60,30,10,.10) 4px),
    repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(40,20,5,.08) 8px, rgba(40,20,5,.08) 9px),
    linear-gradient(135deg, #8b5e34 0%, #7a4e28 50%, #8a5a30 100%);
}

/* highlights */
.square.selected {
  box-shadow: inset 0 0 0 3px #ffe066cc;
  z-index: 2;
}
.square.last-move {
  box-shadow: inset 0 0 0 3px #c8a84488;
}
.square.check-highlight {
  background: radial-gradient(ellipse at center, #ff3333cc 0%, #cc000088 60%, transparent 80%) !important;
}

/* valid move dot */
.move-dot {
  position: absolute;
  width: 20px; height: 20px;
  background: radial-gradient(circle, rgba(80,180,80,.7) 0%, rgba(60,160,60,.4) 60%, transparent 70%);
  border-radius: 50%;
  pointer-events: none;
  z-index: 1;
}

/* capture ring */
.capture-ring {
  position: absolute;
  width: 64px; height: 64px;
  border: 3px solid rgba(80,180,80,.55);
  border-radius: 50%;
  pointer-events: none;
  z-index: 1;
}

/* piece */
.piece {
  font-size: 2.8rem;
  line-height: 1;
  z-index: 3;
  text-shadow: 0 2px 6px rgba(0,0,0,.5);
  transition: transform .1s;
  pointer-events: none;
}
.piece-white { color: #fff; filter: drop-shadow(0 1px 2px rgba(0,0,0,.6)); }
.piece-black { color: #1a1a1a; filter: drop-shadow(0 1px 2px rgba(255,255,255,.15)); }

.square:hover { filter: brightness(1.08); }

/* ---------- buttons ---------- */
.btn-row {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn {
  padding: 8px 18px;
  background: linear-gradient(180deg, #6b4420, #4a2e12);
  border: 1px solid #8a5a30;
  border-radius: 6px;
  color: #e8d5b0;
  font-size: .9rem;
  cursor: pointer;
  transition: all .15s;
  font-family: inherit;
}
.btn:hover { background: linear-gradient(180deg, #7d5228, #5a3818); transform: translateY(-1px); }
.btn:active { transform: translateY(0); }
.btn:disabled { opacity: .4; cursor: not-allowed; }

/* ---------- modal ---------- */
.modal-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,.65);
  display: flex; align-items: center; justify-content: center;
  z-index: 100;
}
.modal {
  background: linear-gradient(180deg, #3e2812, #2a1a0c);
  border: 2px solid #8a5a30;
  border-radius: 14px;
  padding: 28px 36px;
  text-align: center;
  box-shadow: 0 12px 40px rgba(0,0,0,.7);
  min-width: 280px;
}
.modal h2 { font-size: 1.4rem; margin-bottom: 18px; color: #f0d9a0; }
.modal .btn { margin: 6px; font-size: 1rem; padding: 10px 28px; }
.modal .promo-pieces { font-size: 2.6rem; display: flex; gap: 12px; justify-content: center; margin: 12px 0 18px; }
.modal .promo-pieces span {
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 8px;
  border: 2px solid transparent;
  transition: all .15s;
}
.modal .promo-pieces span:hover { border-color: #ffe066; background: rgba(255,255,255,.08); }

/* responsive */
@media (max-width: 960px) {
  .side-panel { width: 100%; max-width: 580px; }
  #app { flex-direction: column; align-items: center; }
}
</style>
</head>
<body>

<h1>国际象棋</h1>

<div id="app">
  <!-- left panel -->
  <div class="side-panel" id="left-panel">
    <div class="captured-box">
      <h3 id="captured-title-top">被吃掉的棋子</h3>
      <div class="captured-pieces" id="captured-top"></div>
    </div>
    <div id="history-box">
      <h3>走棋记录</h3>
      <div id="history-list"></div>
    </div>
  </div>

  <!-- board -->
  <div id="board-area">
    <div id="status-bar">请选择执棋颜色开始游戏</div>
    <div id="board-perspective">
      <div id="board-3d">
        <div id="board"></div>
      </div>
    </div>
    <div class="board-labels-file" id="file-labels"></div>
    <div class="btn-row" style="margin-top:8px">
      <button class="btn" id="btn-undo" disabled>悔棋</button>
      <button class="btn" id="btn-new">新游戏</button>
    </div>
  </div>

  <!-- right panel -->
  <div class="side-panel" id="right-panel">
    <div class="captured-box">
      <h3 id="captured-title-bottom">被吃掉的棋子</h3>
      <div class="captured-pieces" id="captured-bottom"></div>
    </div>
  </div>
</div>

<!-- choose side modal -->
<div class="modal-overlay" id="modal-choose">
  <div class="modal">
    <h2>选择执棋颜色</h2>
    <button class="btn" id="choose-white">执白 ♔</button>
    <button class="btn" id="choose-black">执黑 ♚</button>
  </div>
</div>

<!-- promotion modal (hidden) -->
<div class="modal-overlay" id="modal-promo" style="display:none">
  <div class="modal">
    <h2>兵的升变</h2>
    <div class="promo-pieces" id="promo-pieces"></div>
  </div>
</div>

<!-- game over modal (hidden) -->
<div class="modal-overlay" id="modal-gameover" style="display:none">
  <div class="modal">
    <h2 id="gameover-text"></h2>
    <button class="btn" id="btn-gameover-new">再来一局</button>
  </div>
</div>

<script>
/* ================================================================
   国际象棋  – complete chess with AI (minimax + alpha-beta)
   ================================================================ */

// ---- constants ----
const W = 'w', B = 'b';
const KING = 'K', QUEEN = 'Q', ROOK = 'R', BISHOP = 'B', KNIGHT = 'N', PAWN = 'P';

const UNICODE_PIECES = {
  wK: '\u2654', wQ: '\u2655', wR: '\u2656', wB: '\u2657', wN: '\u2658', wP: '\u2659',
  bK: '\u265A', bQ: '\u265B', bR: '\u265C', bB: '\u265D', bN: '\u265E', bP: '\u265F'
};

const PIECE_VALUES = { P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000 };

const PIECE_NAMES_CN = { K: '王', Q: '后', R: '车', B: '象', N: '马', P: '兵' };

// PST (piece-square tables) – white perspective (flip for black)
const PST = {
  P: [
     0,  0,  0,  0,  0,  0,  0,  0,
    50, 50, 50, 50, 50, 50, 50, 50,
    10, 10, 20, 30, 30, 20, 10, 10,
     5,  5, 10, 25, 25, 10,  5,  5,
     0,  0,  0, 20, 20,  0,  0,  0,
     5, -5,-10,  0,  0,-10, -5,  5,
     5, 10, 10,-20,-20, 10, 10,  5,
     0,  0,  0,  0,  0,  0,  0,  0
  ],
  N: [
   -50,-40,-30,-30,-30,-30,-40,-50,
   -40,-20,  0,  0,  0,  0,-20,-40,
   -30,  0, 10, 15, 15, 10,  0,-30,
   -30,  5, 15, 20, 20, 15,  5,-30,
   -30,  0, 15, 20, 20, 15,  0,-30,
   -30,  5, 10, 15, 15, 10,  5,-30,
   -40,-20,  0,  5,  5,  0,-20,-40,
   -50,-40,-30,-30,-30,-30,-40,-50
  ],
  B: [
   -20,-10,-10,-10,-10,-10,-10,-20,
   -10,  0,  0,  0,  0,  0,  0,-10,
   -10,  0, 10, 10, 10, 10,  0,-10,
   -10,  5,  5, 10, 10,  5,  5,-10,
   -10,  0, 10, 10, 10, 10,  0,-10,
   -10, 10, 10, 10, 10, 10, 10,-10,
   -10,  5,  0,  0,  0,  0,  5,-10,
   -20,-10,-10,-10,-10,-10,-10,-20
  ],
  R: [
     0,  0,  0,  0,  0,  0,  0,  0,
     5, 10, 10, 10, 10, 10, 10,  5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
     0,  0,  0,  5,  5,  0,  0,  0
  ],
  Q: [
   -20,-10,-10, -5, -5,-10,-10,-20,
   -10,  0,  0,  0,  0,  0,  0,-10,
   -10,  0,  5,  5,  5,  5,  0,-10,
    -5,  0,  5,  5,  5,  5,  0, -5,
     0,  0,  5,  5,  5,  5,  0, -5,
   -10,  5,  5,  5,  5,  5,  0,-10,
   -10,  0,  5,  0,  0,  0,  0,-10,
   -20,-10,-10, -5, -5,-10,-10,-20
  ],
  K: [
   -30,-40,-40,-50,-50,-40,-40,-30,
   -30,-40,-40,-50,-50,-40,-40,-30,
   -30,-40,-40,-50,-50,-40,-40,-30,
   -30,-40,-40,-50,-50,-40,-40,-30,
   -20,-30,-30,-40,-40,-30,-30,-20,
   -10,-20,-20,-20,-20,-20,-20,-10,
    20, 20,  0,  0,  0,  0, 20, 20,
    20, 30, 10,  0,  0, 10, 30, 20
  ],
  K_end: [
   -50,-40,-30,-20,-20,-30,-40,-50,
   -30,-20,-10,  0,  0,-10,-20,-30,
   -30,-10, 20, 30, 30, 20,-10,-30,
   -30,-10, 30, 40, 40, 30,-10,-30,
   -30,-10, 30, 40, 40, 30,-10,-30,
   -30,-10, 20, 30, 30, 20,-10,-30,
   -30,-30,  0,  0,  0,  0,-30,-30,
   -50,-30,-30,-30,-30,-30,-30,-50
  ]
};

// ---- game state ----
let board = [];      // 8x8 array, null or {color, type}
let turn = W;
let playerColor = W;
let aiColor = B;
let selected = null; // {r, c}
let validMoves = []; // [{r, c, special}]
let moveHistory = []; // full move objects for undo
let historyNotation = []; // algebraic notation strings
let capturedWhite = [];
let capturedBlack = [];
let castlingRights = { wK: true, wQ: true, bK: true, bQ: true };
let enPassantTarget = null; // {r, c} or null
let halfMoveClock = 0;
let fullMoveNumber = 1;
let lastMove = null; // {from, to}
let gameOver = false;
let aiThinking = false;
let positionHistory = []; // for threefold repetition

// ---- DOM refs ----
const boardEl = document.getElementById('board');
const statusBar = document.getElementById('status-bar');
const historyList = document.getElementById('history-list');
const capturedTopEl = document.getElementById('captured-top');
const capturedBottomEl = document.getElementById('captured-bottom');
const capturedTitleTop = document.getElementById('captured-title-top');
const capturedTitleBottom = document.getElementById('captured-title-bottom');
const btnUndo = document.getElementById('btn-undo');
const btnNew = document.getElementById('btn-new');
const modalChoose = document.getElementById('modal-choose');
const modalPromo = document.getElementById('modal-promo');
const promoPiecesEl = document.getElementById('promo-pieces');
const modalGameover = document.getElementById('modal-gameover');
const gameoverText = document.getElementById('gameover-text');
const fileLabelsEl = document.getElementById('file-labels');

// ---- initialization ----
function initBoard() {
  board = Array.from({length:8}, () => Array(8).fill(null));
  const backRank = [ROOK, KNIGHT, BISHOP, QUEEN, KING, BISHOP, KNIGHT, ROOK];
  for (let c = 0; c < 8; c++) {
    board[0][c] = {color: B, type: backRank[c]};
    board[1][c] = {color: B, type: PAWN};
    board[6][c] = {color: W, type: PAWN};
    board[7][c] = {color: W, type: backRank[c]};
  }
  turn = W;
  selected = null;
  validMoves = [];
  moveHistory = [];
  historyNotation = [];
  capturedWhite = [];
  capturedBlack = [];
  castlingRights = { wK: true, wQ: true, bK: true, bQ: true };
  enPassantTarget = null;
  halfMoveClock = 0;
  fullMoveNumber = 1;
  lastMove = null;
  gameOver = false;
  aiThinking = false;
  positionHistory = [];
  positionHistory.push(boardHash());
}

function newGame(color) {
  playerColor = color;
  aiColor = color === W ? B : W;
  initBoard();
  modalChoose.style.display = 'none';
  modalGameover.style.display = 'none';

  // set labels based on player orientation
  capturedTitleTop.textContent = playerColor === W ? '黑方被吃' : '白方被吃';
  capturedTitleBottom.textContent = playerColor === W ? '白方被吃' : '黑方被吃';

  renderBoard();
  updateStatus();
  renderHistory();
  renderCaptured();
  btnUndo.disabled = true;

  if (turn === aiColor) {
    setTimeout(doAIMove, 300);
  }
}

// ---- board rendering ----
function renderBoard() {
  boardEl.innerHTML = '';
  const flipped = playerColor === B;

  for (let ri = 0; ri < 8; ri++) {
    for (let ci = 0; ci < 8; ci++) {
      const r = flipped ? 7 - ri : ri;
      const c = flipped ? 7 - ci : ci;

      const sq = document.createElement('div');
      const isLight = (r + c) % 2 === 0;
      sq.className = 'square ' + (isLight ? 'square-light' : 'square-dark');
      sq.dataset.r = r;
      sq.dataset.c = c;

      // last move highlight
      if (lastMove && ((lastMove.from.r === r && lastMove.from.c === c) || (lastMove.to.r === r && lastMove.to.c === c))) {
        sq.classList.add('last-move');
      }

      // selected
      if (selected && selected.r === r && selected.c === c) {
        sq.classList.add('selected');
      }

      // check highlight
      const p = board[r][c];
      if (p && p.type === KING && isInCheck(p.color)) {
        sq.classList.add('check-highlight');
      }

      // valid move markers
      const vm = validMoves.find(m => m.r === r && m.c === c);
      if (vm) {
        const marker = document.createElement('div');
        marker.className = board[r][c] ? 'capture-ring' : 'move-dot';
        sq.appendChild(marker);
      }

      // piece
      if (p) {
        const span = document.createElement('span');
        span.className = 'piece ' + (p.color === W ? 'piece-white' : 'piece-black');
        span.textContent = UNICODE_PIECES[p.color + p.type];
        sq.appendChild(span);
      }

      sq.addEventListener('click', () => onSquareClick(r, c));
      boardEl.appendChild(sq);
    }
  }

  // file labels
  fileLabelsEl.innerHTML = '';
  const files = 'abcdefgh';
  for (let i = 0; i < 8; i++) {
    const ci = flipped ? 7 - i : i;
    const lbl = document.createElement('span');
    lbl.textContent = files[ci];
    fileLabelsEl.appendChild(lbl);
  }
}

// ---- interaction ----
function onSquareClick(r, c) {
  if (gameOver || aiThinking) return;
  if (turn !== playerColor) return;

  const piece = board[r][c];

  // if a valid move target is clicked
  const vm = validMoves.find(m => m.r === r && m.c === c);
  if (selected && vm) {
    executePlayerMove(selected.r, selected.c, r, c, vm.special);
    return;
  }

  // select own piece
  if (piece && piece.color === turn) {
    selected = {r, c};
    validMoves = getLegalMoves(r, c);
    renderBoard();
    return;
  }

  // deselect
  selected = null;
  validMoves = [];
  renderBoard();
}

function executePlayerMove(fr, fc, tr, tc, special) {
  // check promotion
  const piece = board[fr][fc];
  if (piece.type === PAWN && (tr === 0 || tr === 7)) {
    showPromotionModal(fr, fc, tr, tc, special);
    return;
  }
  doMove(fr, fc, tr, tc, special);
  afterMove();
}

function showPromotionModal(fr, fc, tr, tc, special) {
  modalPromo.style.display = 'flex';
  const color = board[fr][fc].color;
  promoPiecesEl.innerHTML = '';
  [QUEEN, ROOK, BISHOP, KNIGHT].forEach(pt => {
    const span = document.createElement('span');
    span.className = color === W ? 'piece-white' : 'piece-black';
    span.textContent = UNICODE_PIECES[color + pt];
    span.addEventListener('click', () => {
      modalPromo.style.display = 'none';
      doMove(fr, fc, tr, tc, {type: 'promotion', promoteTo: pt});
      afterMove();
    });
    promoPiecesEl.appendChild(span);
  });
}

function afterMove() {
  selected = null;
  validMoves = [];
  renderBoard();
  renderHistory();
  renderCaptured();
  updateStatus();
  btnUndo.disabled = moveHistory.length === 0;

  if (gameOver) return;

  if (turn === aiColor) {
    aiThinking = true;
    statusBar.textContent = 'AI 思考中...';
    setTimeout(doAIMove, 50);
  }
}

function doAIMove() {
  if (gameOver) { aiThinking = false; return; }
  const move = findBestMove();
  if (!move) { aiThinking = false; return; }
  doMove(move.fr, move.fc, move.tr, move.tc, move.special);
  aiThinking = false;
  selected = null;
  validMoves = [];
  renderBoard();
  renderHistory();
  renderCaptured();
  updateStatus();
  btnUndo.disabled = moveHistory.length === 0;
}

// ---- move execution ----
function doMove(fr, fc, tr, tc, special) {
  const piece = board[fr][fc];
  const captured = board[tr][tc];

  // save state for undo
  const undoInfo = {
    fr, fc, tr, tc,
    piece: {...piece},
    captured: captured ? {...captured} : null,
    special: special,
    castlingRights: {...castlingRights},
    enPassantTarget: enPassantTarget ? {...enPassantTarget} : null,
    halfMoveClock,
    fullMoveNumber,
    lastMove: lastMove ? {from: {...lastMove.from}, to: {...lastMove.to}} : null
  };

  // build notation before move
  const notation = buildNotation(fr, fc, tr, tc, special, piece, captured);

  // handle special moves
  let epCaptured = null;
  if (special && special.type === 'enpassant') {
    const epR = piece.color === W ? tr + 1 : tr - 1;
    epCaptured = board[epR][tc];
    undoInfo.epCapturedR = epR;
    undoInfo.epCaptured = {...epCaptured};
    board[epR][tc] = null;
  }

  if (special && special.type === 'castleK') {
    board[fr][7] = null;
    board[fr][5] = {color: piece.color, type: ROOK};
  }
  if (special && special.type === 'castleQ') {
    board[fr][0] = null;
    board[fr][3] = {color: piece.color, type: ROOK};
  }

  // move piece
  board[tr][tc] = piece;
  board[fr][fc] = null;

  // promotion
  if (special && special.type === 'promotion') {
    board[tr][tc] = {color: piece.color, type: special.promoteTo};
  }

  // update castling rights
  if (piece.type === KING) {
    if (piece.color === W) { castlingRights.wK = false; castlingRights.wQ = false; }
    else { castlingRights.bK = false; castlingRights.bQ = false; }
  }
  if (piece.type === ROOK) {
    if (piece.color === W && fr === 7 && fc === 0) castlingRights.wQ = false;
    if (piece.color === W && fr === 7 && fc === 7) castlingRights.wK = false;
    if (piece.color === B && fr === 0 && fc === 0) castlingRights.bQ = false;
    if (piece.color === B && fr === 0 && fc === 7) castlingRights.bK = false;
  }
  // rook captured
  if (captured && captured.type === ROOK) {
    if (captured.color === W && tr === 7 && tc === 0) castlingRights.wQ = false;
    if (captured.color === W && tr === 7 && tc === 7) castlingRights.wK = false;
    if (captured.color === B && tr === 0 && tc === 0) castlingRights.bQ = false;
    if (captured.color === B && tr === 0 && tc === 7) castlingRights.bK = false;
  }

  // en passant target
  if (piece.type === PAWN && Math.abs(tr - fr) === 2) {
    enPassantTarget = {r: (fr + tr) / 2, c: fc};
  } else {
    enPassantTarget = null;
  }

  // half move clock
  if (piece.type === PAWN || captured || epCaptured) {
    halfMoveClock = 0;
  } else {
    halfMoveClock++;
  }

  // captured pieces
  if (captured) {
    if (captured.color === W) capturedWhite.push(captured.type);
    else capturedBlack.push(captured.type);
  }
  if (epCaptured) {
    if (epCaptured.color === W) capturedWhite.push(epCaptured.type);
    else capturedBlack.push(epCaptured.type);
  }

  lastMove = {from: {r: fr, c: fc}, to: {r: tr, c: tc}};

  // check / checkmate notation
  const opp = piece.color === W ? B : W;
  if (isInCheck(opp)) {
    if (isCheckmate(opp)) {
      notation.text += '#';
    } else {
      notation.text += '+';
    }
  }

  // switch turn
  if (turn === B) fullMoveNumber++;
  turn = turn === W ? B : W;

  undoInfo.notation = notation.text;
  moveHistory.push(undoInfo);
  historyNotation.push(notation.text);

  // position history for threefold repetition
  positionHistory.push(boardHash());
}

function undoMove() {
  if (moveHistory.length === 0) return;
  // undo AI move and player move (2 moves)
  for (let i = 0; i < 2 && moveHistory.length > 0; i++) {
    const u = moveHistory.pop();
    historyNotation.pop();
    positionHistory.pop();

    board[u.fr][u.fc] = u.piece;
    board[u.tr][u.tc] = u.captured;

    if (u.special && u.special.type === 'enpassant') {
      board[u.epCapturedR][u.tc] = u.epCaptured;
      board[u.tr][u.tc] = null;
    }
    if (u.special && u.special.type === 'castleK') {
      board[u.fr][7] = {color: u.piece.color, type: ROOK};
      board[u.fr][5] = null;
    }
    if (u.special && u.special.type === 'castleQ') {
      board[u.fr][0] = {color: u.piece.color, type: ROOK};
      board[u.fr][3] = null;
    }

    // restore captured pieces
    if (u.captured) {
      if (u.captured.color === W) capturedWhite.pop();
      else capturedBlack.pop();
    }
    if (u.special && u.special.type === 'enpassant') {
      if (u.epCaptured.color === W) capturedWhite.pop();
      else capturedBlack.pop();
    }

    castlingRights = u.castlingRights;
    enPassantTarget = u.enPassantTarget;
    halfMoveClock = u.halfMoveClock;
    fullMoveNumber = u.fullMoveNumber;
    lastMove = u.lastMove;

    turn = turn === W ? B : W;
  }

  gameOver = false;
  selected = null;
  validMoves = [];
  renderBoard();
  renderHistory();
  renderCaptured();
  updateStatus();
  btnUndo.disabled = moveHistory.length === 0;
}

// ---- move generation ----
function inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

function getPseudoMoves(r, c, brd, cr, ep) {
  const piece = brd[r][c];
  if (!piece) return [];
  const moves = [];
  const color = piece.color;
  const opp = color === W ? B : W;
  const dir = color === W ? -1 : 1;

  function addIf(tr, tc, special) {
    if (!inBounds(tr, tc)) return false;
    const target = brd[tr][tc];
    if (target && target.color === color) return false;
    moves.push({r: tr, c: tc, special: special || null});
    return !target; // continue sliding if empty
  }

  switch (piece.type) {
    case PAWN: {
      // forward
      const f1 = r + dir;
      if (inBounds(f1, c) && !brd[f1][c]) {
        const promo = (f1 === 0 || f1 === 7);
        if (promo) {
          [QUEEN, ROOK, BISHOP, KNIGHT].forEach(pt =>
            moves.push({r: f1, c, special: {type:'promotion', promoteTo: pt}}));
        } else {
          moves.push({r: f1, c, special: null});
        }
        // double push
        const startRow = color === W ? 6 : 1;
        const f2 = r + 2 * dir;
        if (r === startRow && !brd[f2][c]) {
          moves.push({r: f2, c, special: null});
        }
      }
      // captures
      for (const dc of [-1, 1]) {
        const tc = c + dc;
        if (!inBounds(f1, tc)) continue;
        const promo = (f1 === 0 || f1 === 7);
        if (brd[f1][tc] && brd[f1][tc].color === opp) {
          if (promo) {
            [QUEEN, ROOK, BISHOP, KNIGHT].forEach(pt =>
              moves.push({r: f1, c: tc, special: {type:'promotion', promoteTo: pt}}));
          } else {
            moves.push({r: f1, c: tc, special: null});
          }
        }
        // en passant
        if (ep && ep.r === f1 && ep.c === tc) {
          moves.push({r: f1, c: tc, special: {type:'enpassant'}});
        }
      }
      break;
    }
    case KNIGHT: {
      const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      offsets.forEach(([dr,dc]) => addIf(r+dr, c+dc));
      break;
    }
    case BISHOP: {
      for (const [dr,dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
        for (let i = 1; i < 8; i++) { if (!addIf(r+dr*i, c+dc*i)) break; }
      }
      break;
    }
    case ROOK: {
      for (const [dr,dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
        for (let i = 1; i < 8; i++) { if (!addIf(r+dr*i, c+dc*i)) break; }
      }
      break;
    }
    case QUEEN: {
      for (const [dr,dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
        for (let i = 1; i < 8; i++) { if (!addIf(r+dr*i, c+dc*i)) break; }
      }
      break;
    }
    case KING: {
      for (const [dr,dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
        addIf(r+dr, c+dc);
      }
      // castling
      const rank = color === W ? 7 : 0;
      if (r === rank && c === 4) {
        const ck = color === W ? cr.wK : cr.bK;
        const cq = color === W ? cr.wQ : cr.bQ;
        if (ck && brd[rank][5] === null && brd[rank][6] === null && brd[rank][7] && brd[rank][7].type === ROOK && brd[rank][7].color === color) {
          if (!isSquareAttacked(rank, 4, opp, brd) && !isSquareAttacked(rank, 5, opp, brd) && !isSquareAttacked(rank, 6, opp, brd)) {
            moves.push({r: rank, c: 6, special: {type:'castleK'}});
          }
        }
        if (cq && brd[rank][3] === null && brd[rank][2] === null && brd[rank][1] === null && brd[rank][0] && brd[rank][0].type === ROOK && brd[rank][0].color === color) {
          if (!isSquareAttacked(rank, 4, opp, brd) && !isSquareAttacked(rank, 3, opp, brd) && !isSquareAttacked(rank, 2, opp, brd)) {
            moves.push({r: rank, c: 2, special: {type:'castleQ'}});
          }
        }
      }
      break;
    }
  }
  return moves;
}

function isSquareAttacked(r, c, byColor, brd) {
  // check all opponent pieces
  for (let ri = 0; ri < 8; ri++) {
    for (let ci = 0; ci < 8; ci++) {
      const p = brd[ri][ci];
      if (!p || p.color !== byColor) continue;
      // simplified attack check
      const dr = r - ri, dc = c - ci;
      const adr = Math.abs(dr), adc = Math.abs(dc);
      switch (p.type) {
        case PAWN: {
          const pdir = byColor === W ? -1 : 1;
          if (dr === pdir && adc === 1) return true;
          break;
        }
        case KNIGHT:
          if ((adr === 2 && adc === 1) || (adr === 1 && adc === 2)) return true;
          break;
        case KING:
          if (adr <= 1 && adc <= 1) return true;
          break;
        case BISHOP:
          if (adr === adc && adr > 0) { if (isClearDiagonal(ri, ci, r, c, brd)) return true; }
          break;
        case ROOK:
          if ((dr === 0 || dc === 0) && (adr + adc > 0)) { if (isClearLine(ri, ci, r, c, brd)) return true; }
          break;
        case QUEEN:
          if (adr === adc && adr > 0) { if (isClearDiagonal(ri, ci, r, c, brd)) return true; }
          if ((dr === 0 || dc === 0) && (adr + adc > 0)) { if (isClearLine(ri, ci, r, c, brd)) return true; }
          break;
      }
    }
  }
  return false;
}

function isClearLine(r1, c1, r2, c2, brd) {
  const dr = Math.sign(r2 - r1), dc = Math.sign(c2 - c1);
  let r = r1 + dr, c = c1 + dc;
  while (r !== r2 || c !== c2) {
    if (brd[r][c]) return false;
    r += dr; c += dc;
  }
  return true;
}

function isClearDiagonal(r1, c1, r2, c2, brd) {
  return isClearLine(r1, c1, r2, c2, brd);
}

function findKing(color, brd) {
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++)
      if (brd[r][c] && brd[r][c].type === KING && brd[r][c].color === color) return {r, c};
  return null;
}

function isInCheck(color) {
  const king = findKing(color, board);
  if (!king) return false;
  const opp = color === W ? B : W;
  return isSquareAttacked(king.r, king.c, opp, board);
}

function getLegalMoves(r, c) {
  const piece = board[r][c];
  if (!piece) return [];
  const pseudo = getPseudoMoves(r, c, board, castlingRights, enPassantTarget);
  return pseudo.filter(m => {
    // make move, check if own king is safe
    const saved = simulateMove(r, c, m.r, m.c, m.special, board);
    const king = findKing(piece.color, board);
    const opp = piece.color === W ? B : W;
    const legal = king && !isSquareAttacked(king.r, king.c, opp, board);
    restoreMove(saved, board);
    return legal;
  });
}

function getAllLegalMoves(color) {
  const moves = [];
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (board[r][c] && board[r][c].color === color) {
        const ms = getLegalMoves(r, c);
        ms.forEach(m => moves.push({fr: r, fc: c, tr: m.r, tc: m.c, special: m.special}));
      }
    }
  }
  return moves;
}

function simulateMove(fr, fc, tr, tc, special, brd) {
  const saved = {
    fr, fc, tr, tc,
    fromPiece: brd[fr][fc],
    toPiece: brd[tr][tc],
    special,
    epPiece: null, epR: -1, epC: -1,
    rookFrom: null, rookTo: null, rookPiece: null
  };

  if (special && special.type === 'enpassant') {
    const epR = brd[fr][fc].color === W ? tr + 1 : tr - 1;
    saved.epPiece = brd[epR][tc];
    saved.epR = epR;
    saved.epC = tc;
    brd[epR][tc] = null;
  }

  if (special && special.type === 'castleK') {
    saved.rookPiece = brd[fr][7];
    saved.rookFrom = {r: fr, c: 7};
    saved.rookTo = {r: fr, c: 5};
    brd[fr][5] = brd[fr][7];
    brd[fr][7] = null;
  }
  if (special && special.type === 'castleQ') {
    saved.rookPiece = brd[fr][0];
    saved.rookFrom = {r: fr, c: 0};
    saved.rookTo = {r: fr, c: 3};
    brd[fr][3] = brd[fr][0];
    brd[fr][0] = null;
  }

  brd[tr][tc] = brd[fr][fc];
  brd[fr][fc] = null;

  if (special && special.type === 'promotion') {
    brd[tr][tc] = {color: saved.fromPiece.color, type: special.promoteTo};
  }

  return saved;
}

function restoreMove(saved, brd) {
  brd[saved.fr][saved.fc] = saved.fromPiece;
  brd[saved.tr][saved.tc] = saved.toPiece;

  if (saved.special && saved.special.type === 'enpassant') {
    brd[saved.epR][saved.epC] = saved.epPiece;
    brd[saved.tr][saved.tc] = null;
  }

  if (saved.rookFrom) {
    brd[saved.rookFrom.r][saved.rookFrom.c] = saved.rookPiece;
    brd[saved.rookTo.r][saved.rookTo.c] = null;
  }
}

// ---- check / checkmate / stalemate ----
function isCheckmate(color) {
  if (!isInCheck(color)) return false;
  return getAllLegalMoves(color).length === 0;
}

function isStalemate(color) {
  if (isInCheck(color)) return false;
  return getAllLegalMoves(color).length === 0;
}

function isDraw() {
  // 50-move rule
  if (halfMoveClock >= 100) return '50步不吃子判和';
  // threefold repetition
  const hash = boardHash();
  let count = 0;
  for (const h of positionHistory) { if (h === hash) count++; }
  if (count >= 3) return '三次重复局面判和';
  // insufficient material
  if (isInsufficientMaterial()) return '子力不足判和';
  return null;
}

function isInsufficientMaterial() {
  const pieces = [];
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++)
      if (board[r][c]) pieces.push(board[r][c]);
  if (pieces.length === 2) return true; // K vs K
  if (pieces.length === 3) {
    const nonKing = pieces.find(p => p.type !== KING);
    if (nonKing && (nonKing.type === BISHOP || nonKing.type === KNIGHT)) return true;
  }
  if (pieces.length === 4) {
    const bishops = pieces.filter(p => p.type === BISHOP);
    if (bishops.length === 2 && bishops[0].color !== bishops[1].color) {
      // same colored squares?
      let positions = [];
      for (let r = 0; r < 8; r++)
        for (let c = 0; c < 8; c++)
          if (board[r][c] && board[r][c].type === BISHOP) positions.push((r+c)%2);
      if (positions[0] === positions[1]) return true;
    }
  }
  return false;
}

function boardHash() {
  let h = '';
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      h += p ? (p.color + p.type) : '--';
    }
  h += turn + (castlingRights.wK?'1':'0') + (castlingRights.wQ?'1':'0') +
       (castlingRights.bK?'1':'0') + (castlingRights.bQ?'1':'0');
  if (enPassantTarget) h += enPassantTarget.r + '' + enPassantTarget.c;
  return h;
}

// ---- notation ----
function buildNotation(fr, fc, tr, tc, special, piece, captured) {
  if (special && special.type === 'castleK') return {text: 'O-O'};
  if (special && special.type === 'castleQ') return {text: 'O-O-O'};

  let n = '';
  const files = 'abcdefgh';
  const ranks = '87654321';

  if (piece.type !== PAWN) {
    n += piece.type;
    // disambiguation
    const same = [];
    for (let r = 0; r < 8; r++)
      for (let c = 0; c < 8; c++) {
        if (r === fr && c === fc) continue;
        const p = board[r][c];
        if (p && p.color === piece.color && p.type === piece.type) {
          const moves = getPseudoMoves(r, c, board, castlingRights, enPassantTarget);
          if (moves.some(m => m.r === tr && m.c === tc)) same.push({r, c});
        }
      }
    if (same.length > 0) {
      if (same.every(s => s.c !== fc)) n += files[fc];
      else if (same.every(s => s.r !== fr)) n += ranks[fr];
      else n += files[fc] + ranks[fr];
    }
  } else if (captured || (special && special.type === 'enpassant')) {
    n += files[fc];
  }

  if (captured || (special && special.type === 'enpassant')) n += 'x';

  n += files[tc] + ranks[tr];

  if (special && special.type === 'promotion') {
    n += '=' + special.promoteTo;
  }

  return {text: n};
}

// ---- status update ----
function updateStatus() {
  const draw = isDraw();
  if (draw) {
    gameOver = true;
    statusBar.textContent = '和棋! ' + draw;
    showGameOver('和棋! ' + draw);
    return;
  }

  if (isCheckmate(turn)) {
    gameOver = true;
    const winner = turn === W ? '黑方' : '白方';
    statusBar.textContent = `将杀! ${winner}获胜!`;
    showGameOver(`将杀! ${winner}获胜!`);
    return;
  }

  if (isStalemate(turn)) {
    gameOver = true;
    statusBar.textContent = '逼和! 平局!';
    showGameOver('逼和! 平局!');
    return;
  }

  const turnName = turn === W ? '白方' : '黑方';
  const checkText = isInCheck(turn) ? ' (被将军!)' : '';
  statusBar.textContent = `${turnName}走棋${checkText}`;
}

function showGameOver(text) {
  gameoverText.textContent = text;
  modalGameover.style.display = 'flex';
}

// ---- history rendering ----
function renderHistory() {
  historyList.innerHTML = '';
  for (let i = 0; i < historyNotation.length; i += 2) {
    const row = document.createElement('div');
    row.className = 'history-row';
    const num = document.createElement('span');
    num.className = 'history-num';
    num.textContent = Math.floor(i/2 + 1) + '.';
    const wm = document.createElement('span');
    wm.className = 'history-white';
    wm.textContent = historyNotation[i] || '';
    const bm = document.createElement('span');
    bm.className = 'history-black';
    bm.textContent = historyNotation[i+1] || '';
    row.appendChild(num);
    row.appendChild(wm);
    row.appendChild(bm);
    historyList.appendChild(row);
  }
  // scroll to bottom
  const hbox = document.getElementById('history-box');
  hbox.scrollTop = hbox.scrollHeight;
}

// ---- captured rendering ----
function renderCaptured() {
  const order = [QUEEN, ROOK, BISHOP, KNIGHT, PAWN];
  const sortFn = (a, b) => order.indexOf(a) - order.indexOf(b);

  // top = opponent of player; bottom = player's captured
  const topColor = playerColor === W ? B : W;
  const topCaptured = topColor === W ? capturedWhite : capturedBlack;
  const bottomCaptured = topColor === W ? capturedBlack : capturedWhite;

  capturedTopEl.innerHTML = '';
  [...topCaptured].sort(sortFn).forEach(t => {
    const sp = document.createElement('span');
    sp.textContent = UNICODE_PIECES[topColor + t];
    capturedTopEl.appendChild(sp);
  });

  capturedBottomEl.innerHTML = '';
  const botColor = playerColor;
  [...bottomCaptured].sort(sortFn).forEach(t => {
    const sp = document.createElement('span');
    sp.textContent = UNICODE_PIECES[botColor + t];
    capturedBottomEl.appendChild(sp);
  });
}

// ---- AI (minimax with alpha-beta) ----
function evaluateBoard() {
  let score = 0;
  let whiteQueens = 0, blackQueens = 0;
  // count queens for endgame detection
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (p && p.type === QUEEN) {
        if (p.color === W) whiteQueens++; else blackQueens++;
      }
    }
  const endgame = whiteQueens === 0 && blackQueens === 0;

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (!p) continue;
      let val = PIECE_VALUES[p.type];
      let pstKey = p.type;
      if (p.type === KING && endgame) pstKey = 'K_end';
      const pst = PST[pstKey];
      const idx = p.color === W ? r * 8 + c : (7 - r) * 8 + c;
      val += pst[idx];
      score += p.color === W ? val : -val;
    }
  }

  // mobility bonus (lightweight)
  // skip full legal move gen for speed; count pseudo moves
  return score;
}

function orderMoves(moves) {
  // simple move ordering: captures first, then promotions
  return moves.sort((a, b) => {
    const aCap = board[a.tr][a.tc] ? PIECE_VALUES[board[a.tr][a.tc].type] : 0;
    const bCap = board[b.tr][b.tc] ? PIECE_VALUES[board[b.tr][b.tc].type] : 0;
    const aPromo = (a.special && a.special.type === 'promotion') ? 800 : 0;
    const bPromo = (b.special && b.special.type === 'promotion') ? 800 : 0;
    return (bCap + bPromo) - (aCap + aPromo);
  });
}

function minimax(depth, alpha, beta, isMaximizing) {
  if (depth === 0) return evaluateBoard();

  const color = isMaximizing ? W : B;
  const moves = getAllLegalMovesForAI(color);

  if (moves.length === 0) {
    if (isInCheck(color)) {
      return isMaximizing ? -99999 + (3 - depth) : 99999 - (3 - depth);
    }
    return 0; // stalemate
  }

  orderMoves(moves);

  if (isMaximizing) {
    let maxEval = -Infinity;
    for (const move of moves) {
      const saved = simulateMoveAI(move);
      const eval_ = minimax(depth - 1, alpha, beta, false);
      restoreMoveAI(saved);
      maxEval = Math.max(maxEval, eval_);
      alpha = Math.max(alpha, eval_);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const move of moves) {
      const saved = simulateMoveAI(move);
      const eval_ = minimax(depth - 1, alpha, beta, true);
      restoreMoveAI(saved);
      minEval = Math.min(minEval, eval_);
      beta = Math.min(beta, eval_);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function getAllLegalMovesForAI(color) {
  const moves = [];
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (board[r][c] && board[r][c].color === color) {
        const pseudo = getPseudoMoves(r, c, board, castlingRights, enPassantTarget);
        for (const m of pseudo) {
          const saved = simulateMove(r, c, m.r, m.c, m.special, board);
          const king = findKing(color, board);
          const opp = color === W ? B : W;
          const legal = king && !isSquareAttacked(king.r, king.c, opp, board);
          restoreMove(saved, board);
          if (legal) {
            moves.push({fr: r, fc: c, tr: m.r, tc: m.c, special: m.special});
          }
        }
      }
    }
  }
  return moves;
}

function simulateMoveAI(move) {
  const savedCR = {...castlingRights};
  const savedEP = enPassantTarget ? {...enPassantTarget} : null;
  const s = simulateMove(move.fr, move.fc, move.tr, move.tc, move.special, board);

  // update castling rights for AI simulation
  const piece = s.fromPiece;
  if (piece.type === KING) {
    if (piece.color === W) { castlingRights.wK = false; castlingRights.wQ = false; }
    else { castlingRights.bK = false; castlingRights.bQ = false; }
  }
  if (piece.type === ROOK) {
    if (piece.color === W && s.fr === 7 && s.fc === 0) castlingRights.wQ = false;
    if (piece.color === W && s.fr === 7 && s.fc === 7) castlingRights.wK = false;
    if (piece.color === B && s.fr === 0 && s.fc === 0) castlingRights.bQ = false;
    if (piece.color === B && s.fr === 0 && s.fc === 7) castlingRights.bK = false;
  }
  if (s.toPiece && s.toPiece.type === ROOK) {
    if (s.toPiece.color === W && s.tr === 7 && s.tc === 0) castlingRights.wQ = false;
    if (s.toPiece.color === W && s.tr === 7 && s.tc === 7) castlingRights.wK = false;
    if (s.toPiece.color === B && s.tr === 0 && s.tc === 0) castlingRights.bQ = false;
    if (s.toPiece.color === B && s.tr === 0 && s.tc === 7) castlingRights.bK = false;
  }

  // update en passant
  if (piece.type === PAWN && Math.abs(move.tr - move.fr) === 2) {
    enPassantTarget = {r: (move.fr + move.tr) / 2, c: move.fc};
  } else {
    enPassantTarget = null;
  }

  s.savedCR = savedCR;
  s.savedEP = savedEP;
  return s;
}

function restoreMoveAI(saved) {
  restoreMove(saved, board);
  castlingRights = saved.savedCR;
  enPassantTarget = saved.savedEP;
}

function findBestMove() {
  const moves = getAllLegalMovesForAI(aiColor);
  if (moves.length === 0) return null;

  orderMoves(moves);

  const isMax = aiColor === W;
  let bestScore = isMax ? -Infinity : Infinity;
  let bestMoves = [];

  for (const move of moves) {
    const saved = simulateMoveAI(move);
    const score = minimax(2, -Infinity, Infinity, !isMax); // depth-1 more since we already did 1
    restoreMoveAI(saved);

    if ((isMax && score > bestScore) || (!isMax && score < bestScore)) {
      bestScore = score;
      bestMoves = [move];
    } else if (score === bestScore) {
      bestMoves.push(move);
    }
  }

  // random among equal best
  return bestMoves[Math.floor(Math.random() * bestMoves.length)];
}

// ---- event listeners ----
document.getElementById('choose-white').addEventListener('click', () => newGame(W));
document.getElementById('choose-black').addEventListener('click', () => newGame(B));
btnNew.addEventListener('click', () => {
  modalGameover.style.display = 'none';
  modalChoose.style.display = 'flex';
});
document.getElementById('btn-gameover-new').addEventListener('click', () => {
  modalGameover.style.display = 'none';
  modalChoose.style.display = 'flex';
});
btnUndo.addEventListener('click', undoMove);

// init: show choose modal
initBoard();
renderBoard();
</script>
</body>
</html>
